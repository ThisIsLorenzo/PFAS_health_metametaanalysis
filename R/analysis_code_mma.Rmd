---
title: "Analysis Code"
author: "Lorenzo Ricolfi"
output:
  html_document:
    code_folding: show
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    toc_depth: 3
    number_sections: no
    theme: cerulean
    css: styles.css
  pdf_document:
    toc: yes
    toc_depth: '2'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Link to the pre-registered Research Protocol: https://osf.io/dc5mx

**Review questions:**

1.	How does exposure to per- and polyfluoroalkyl substances (PFAS) affect human health?
2.	Which PFAS are linked to adverse health effects, and what are the associated health outcomes?
3.	What are the significant associations between individual PFAS and specific health outcomes, and how strong are these correlations?
4.	How consistent are the findings regarding PFAS-health outcome associations across different meta-analyses?

**Objectives:**

1.	To evaluate the magnitude and variability of associations between PFAS exposure and human health outcomes based on multiple meta-analyses.
2.	To identify specific PFAS (e.g., perfluorooctane sulfonate (PFOS)) significantly associated with adverse health effects and the specific health outcomes impacted.
3.	To determine significant PFAS-health outcome correlations and assess the strength of these relationships.
4.	To assess the consistency of findings from objectives 2 and 3 by analyzing the heterogeneity across meta-analyses.

**Research approach:**

In this meta-meta-analysis, we model meta-analytic estimates from existing meta-analyses. We also model heterogeneity metrics reported by those meta-analyses.
In this analysis workflow, we answer to research question 4 within research questions 1, 2, and 3. In other words, every time we assess the magnitude of results we also assess the consistency of results.

# Packages

```{r, results=FALSE, warning=FALSE, message=FALSE}
# tidy
# rm(list=ls())
# Install and load necessary library
pacman::p_load(tidyr,
               dplyr,
               here,
               ggplot2,
               gridExtra,
               metafor,
               orchaRd,
               stringr,
               cowplot,
               purrr,
               broom,
               clubSandwich,
               ggrepel,
               kableExtra,
               ggMarginal,
               flextable,
               officer,
               ggExtra
               )       
```

# Data loading, wrangling and cleaning

```{r, results=FALSE}
# Load the 'ma_details' and 'ma_e_details' datasets from the 'data' folder using the 'here' package
ma_details <- read.csv(here("data/ma_details.csv"))
ma_e_details <- read.csv(here("data/ma_e_details.csv"))

# Creating a data set for qualitative synthesis (i.e., dat_qual)
# Filter and clean 'ma_e_details', then join with 'ma_details'
dat_qual <- ma_e_details %>%
  # Keep only rows where chemical class is PFAS
  filter(chemical_class == "PFAS") %>%
  # Standardize naming of effect size measures
  mutate(ma_es_measure = recode(
    ma_es_measure,
    "? (regression coefficient) value" = "Beta (regression coefficient) value",
    "beta (regression coefficient) value" = "Beta (regression coefficient) value",
    "Adjusted ? (regression coefficient)" = "Beta (regression coefficient) value",
    "adjusted coefficient regression (?)" = "Beta (regression coefficient) value",
    "relative risk" = "Risk ratio",
    "RR (risk ratio)" = "Risk ratio",
    "OR (odds ratio)" = "Odds ratio",
    "fishers z" = "Fisher's Z",
    "log OR (odds ratio)" = "log Odds ratio")) %>% 
  # Standardize naming of chemical identifiers
  mutate(chemical_id = recode(
    chemical_id,
    "n-PFOA" = "PFOA",
    "n-PFOS" = "PFOS",
    "PFHsX" = "PFHxS")) %>%
  mutate(I_squared = as.numeric(I_squared)) %>%
  mutate(I_squared = if_else(model == "fixed effects model" & I_squared == 0, NA_real_, I_squared)) %>% 
  # Merging 'ma_details' and 'ma_e_details' using the common key 'ma_id'
  left_join(ma_details, by = "ma_id", suffix = c("", ".remove")) %>% 
  select(-ends_with(".remove")) %>% 
  filter(status != "excluded") %>% 
  mutate(ma_journal = tolower(ma_journal),
         ma_journal = gsub("^\\s+|\\s+$", "", ma_journal))
```

# Effect size conversion

To address the challenge of different effect size metrics reported across the included meta-analyses, I developed a conversion function (*convert_to_logOR()*) to standardize all effect sizes to the log odds ratio (logOR) scale. 

This function systematically converted odds ratios, standardized mean differences, risk ratios (with or without baseline risk adjustment), Fisherâ€™s z values, and logistic regression coefficients to logOR values, based on established methodological approximations (e.g., Borenstein et al., 2021).

```{r, results=FALSE}
# Define a conversion function with an optional baseline risk parameter
convert_to_logOR <- function(effect_measure, point_estimate, ma_l_ci, ma_u_ci, regression_type = NA, baseline_risk = NA) {
  # Ensure the effect measure is treated as character
  effect_measure <- as.character(effect_measure)
  # Ensure point estimate, lower CI, and upper CI are numeric
  point_estimate <- suppressWarnings(as.numeric(as.character(point_estimate)))
  ma_l_ci <- suppressWarnings(as.numeric(as.character(ma_l_ci)))
  ma_u_ci <- suppressWarnings(as.numeric(as.character(ma_u_ci)))
  
  # Conversion for Odds ratio and log Odds ratio
  if (effect_measure == "Odds ratio") {
    # Convert OR to logOR
    return(c(log(point_estimate), log(ma_l_ci), log(ma_u_ci)))
    
  } else if (effect_measure == "log Odds ratio") {
    # Already in logOR
    return(c(point_estimate, ma_l_ci, ma_u_ci))
    
    # Conversion for SMD (standardized mean difference)
  } else if (effect_measure == "SMD (standardized mean difference)") {
    # Following Borenstein et al. (2021): logOR = SMD * pi/sqrt(3)
    logOR_point_estimate <- point_estimate * (pi / sqrt(3))
    
    # Convert lower and upper confidence intervals using the same logic
    logOR_l_ci <- ma_l_ci * (pi / sqrt(3))
    logOR_u_ci <- ma_u_ci * (pi / sqrt(3))
    
    return(c(logOR_point_estimate, logOR_l_ci, logOR_u_ci))
    
    # Conversion for Relative risk / Risk ratio with optional baseline risk
  } else if (effect_measure == "Risk ratio") {
    if (!is.na(baseline_risk)) {
      # Using the conversion: OR = RR * (1-p0) / (1-RR*p0)
      OR <- point_estimate * (1 - baseline_risk) / (1 - point_estimate * baseline_risk)
      OR_l_ci <- ma_l_ci * (1 - baseline_risk) / (1 - ma_l_ci * baseline_risk)
      OR_u_ci <- ma_u_ci * (1 - baseline_risk) / (1 - ma_u_ci * baseline_risk)
      return(c(log(OR), log(OR_l_ci), log(OR_u_ci)))
    } else {
      # If no baseline risk is provided, fallback to the approximation:
      return(c(log(point_estimate), log(ma_l_ci), log(ma_u_ci)))
    }
    
    # Conversion for Fisher's z (often used for correlations)
  } else if (grepl("fishers z", effect_measure, ignore.case = TRUE)) {
    # Convert z to correlation, then to logOR.
    # r = tanh(z)
    # Approximation: logOR = r * pi/sqrt(3)
    r <- tanh(point_estimate)
    return(r * (pi / sqrt(3)))
    
    # Conversion for regression coefficients assumed from logistic regression:
  } else if (effect_measure %in% c("Beta (regression coefficient) value")) {
    # Check if regression_type is 'logistic'
    if (!is.na(regression_type) && regression_type == "logistic") {
      return(c(point_estimate, ma_l_ci, ma_u_ci))
    } else {
      return(rep(NA, 3)) # Not logistic regression, cannot convert
    }
  } else {
    warning("Effect measure conversion not implemented for: ", effect_measure)
    return(rep(NA, 3)) # Return NA for all three
  }
}
```

# Effect size calculation

```{r, results=FALSE, warning=FALSE}
# conversion function to transform effect size metrics into logOR
source(here("function", "conversion.R"))

# Creating a data set for quantitative synthesis (i.e., dat_quant)
# Apply conversion to each row
dat_quant <- dat_qual %>%
  # Apply operations row by row instead of column-wise
  rowwise() %>%
  mutate(
    # Convert various effect size measures to log odds ratios using the custom function
    converted = list(convert_to_logOR(ma_es_measure, ma_point_estimate,
                                     ma_l_ci, ma_u_ci, regression_type, 0.1)),
     # Extract the log odds ratio point estimate from the conversion result
    logOR = converted[1],
    # Extract the lower bound of the log odds ratio confidence interval
    l_ci_logOR = converted[2],
    # Extract the upper bound of the log odds ratio confidence interval
    u_ci_logOR = converted[3]
  ) %>%
  # Return to regular (non-rowwise) tibble structure
  ungroup() %>%
  # Remove the temporary 'converted' list column
  select(-converted) %>% 
  # Keep only rows where the log odds ratio was successfully calculated
  filter(!is.na(logOR))
```

# Removing duplicated meta-analytic estimates

```{r}
dat_quant <- dat_quant %>%
  group_by(chemical_id, health_outcome_group) %>%
  mutate(
    duplicate_set = paste(chemical_id, health_outcome_group, ma_point_estimate, ma_l_ci, ma_u_ci)
  ) %>%
  filter(!duplicated(duplicate_set)) %>%
  select(-duplicate_set) %>%              
  ungroup()
```

Seven meta-analytic estimates were removed because they were duplicates (exact same point estimate, confidence intervals, chemical identity, and health outcome group). Duplicates in meta-analytic estimates occur when two or more meta-analytic estimates are based on exactly the same set of primary studies.

# Testing the impact of our conversion strategy

I assessed whether the original effect size metric (ma_es_measure in the following model) influenced the meta-meta-analysis results by including it as a moderator in a multilevel meta-analytic model (random effects: meta-analysis ID and effect size ID). 

```{r, include=FALSE, warning=FALSE}
dat_quant$ma_es_measure <- as.factor(dat_quant$ma_es_measure)
dat_quant$ma_es_measure <- relevel(dat_quant$ma_es_measure, ref = "Odds ratio")

dat_quant <- dat_quant %>%
  mutate(ma_es_measure = recode(
    ma_es_measure,
    "Beta (regression coefficient) value" = "Beta",
    "SMD (standardized mean difference)" = "SMD")) %>% 
  mutate(se = ((u_ci_logOR - l_ci_logOR)/(2*1.96)))  # Convert 95% CI to standard error (se)
```

```{r, results=FALSE, warning=FALSE}
dat_quant <- dat_quant %>% 
  mutate(pair = paste0(health_outcome_group, chemical_id)) # The new variable 'pair' will be used as cluster in the impute_covariance_matrix() function, effectively creating a variance-covariance matrix.

# Create the VCV matrix assuming rho = 0.5 for within-pair correlation
VCV_test <- impute_covariance_matrix(vi = dat_quant$se^2,  
                                cluster = dat_quant$pair,
                                r = 0.5)

mod_test <- rma.mv(yi = logOR,  
              V = VCV_test, 
              random = list(~1|ma_id, 
                            ~1|ma_e_id), 
              mods = ~ ma_es_measure - 1,
              data = dat_quant)
```

```{r, include=FALSE, warning=FALSE}
# Display model results
summary(mod_test)
```

```{r, echo=FALSE, warning=FALSE}
orchard_plot(
  object = mod_test,
  mod = "ma_es_measure",
  group = "ma_id",
  xlab = "log Odds Ratio",
  colour  = FALSE,
  transfm = "none",
  trunk.size = 0.8,
  branch.size = 1.8) + 
  theme(
    panel.border = element_rect(colour = "black", fill = NA, size = 1.3),
    axis.text.x = element_text(size = 10)
  )
```

The moderator analysis revealed a statistically significant impact of the effect size metric on the overall estimates (p = 0.0003). 

To reduce potential bias and improve consistency, I subsequently restricted the dataset to only those effect sizes that were originally reported on the odds ratio (OR) or log odds ratio (logOR) scale (number of effect sizes: 206, number of meta-analyses: 23).

```{r, include=FALSE}
dat_quant <- dat_quant %>% 
  filter(ma_es_measure %in% c("Odds ratio", "log Odds ratio"))
```


# Overview of the Dataset

```{r, echo=FALSE, warning=FALSE}
# Extract the year from 'ma_aut_year'
pub_year_data <- dat_quant %>%
  mutate(pub_year = as.numeric(gsub(".*_(\\d{4})[a-zA-Z]?$", "\\1", ma_aut_year))) %>%
  distinct(ma_id, .keep_all = TRUE) %>%
  filter(!is.na(pub_year))

ggplot(pub_year_data, aes(x = pub_year)) +
  geom_bar(fill = "steelblue") +
  geom_text(stat = "count", aes(label = after_stat(count)), vjust = -0.3, size = 3.5) +
  scale_x_continuous(breaks = seq(min(pub_year_data$pub_year, na.rm = TRUE),
                                  max(pub_year_data$pub_year, na.rm = TRUE), 
                                  by = 1)) +
  labs(title = "Number of Meta-Analyses by Publication Year",
       x = "Year",
       y = "Number of Meta-Analyses") +
  theme_minimal()
```

```{r, echo=FALSE}
# Plot top journals by count (e.g., top 10)
journal_data <- dat_quant %>%
  distinct(ma_id, .keep_all = TRUE) %>%
  count(ma_journal, sort = TRUE) %>%
  top_n(10, n)

ggplot(journal_data, aes(x = reorder(ma_journal, n), y = n)) +
  geom_col(fill = "darkgreen") +
  scale_y_continuous(breaks = seq(0, max(journal_data$n) + 1, by = 1),
                     expand = expansion(mult = c(0, 0.1))) +
  coord_flip() +
  labs(title = "Top 10 Journals Publishing PFAS Meta-Analyses",
       x = "Journal",
       y = "Number of Meta-Analyses") +
  theme_minimal()
```

```{r, echo=FALSE}
# Prepare the data
chemical_s_data <- dat_quant %>%
  distinct(ma_id, .keep_all = TRUE) %>%
  filter(chemical_s %in% c("one", "multiple")) %>%
  count(chemical_s)

# Create a named vector to improve labels
pfas_labels <- c("one" = "Single PFAS", "multiple" = "Multiple PFAS")

# Improved plot
ggplot(chemical_s_data, aes(x = chemical_s, y = n, fill = chemical_s)) +
  geom_col(width = 0.6, show.legend = FALSE) +
  geom_text(aes(label = n), vjust = -0.5, size = 5) +
  scale_x_discrete(labels = pfas_labels) +
  scale_fill_manual(values = c("one" = "#0072B2", "multiple" = "#D55E00")) +
  labs(title = "Number of Meta-Analyses by PFAS Scope",
       x = "PFAS Scope",
       y = "Number of Meta-Analyses") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  ) +
  ylim(0, max(chemical_s_data$n) * 1.1)
```

```{r, echo=FALSE}
## Count the number of occurrences of each chemical_id
chemical_count <- dat_quant %>%
  filter(!is.na(chemical_id) & chemical_id != "") %>% 
  group_by(chemical_id) %>%
  summarise(
    `Number of meta-analyses` = n_distinct(ma_id),
    `Number of health outcomes` = n_distinct(health_outcome_type),
    `Number of health outcome groups` = n_distinct(health_outcome_group),
    `Number of meta-analytic estimates` = sum(!is.na(ma_point_estimate))
  ) %>%
  rename(Chemical = chemical_id) %>%
  arrange(desc(`Number of meta-analyses`))

# Display table with bold caption
chemical_count %>%
  kable(caption = "Table: Chemicals in Meta-Analyses") %>%
  kable_styling(full_width = FALSE)
```

```{r, echo=FALSE}
## Count the number of occurrences of each health outcome type
outcome_type_count <- dat_quant %>%
  filter(!is.na(health_outcome_type) & health_outcome_type != "") %>% 
  group_by(health_outcome_type) %>%
  summarise(
    `Number of meta-analyses` = n_distinct(ma_id),
    `Number of chemicals` = n_distinct(chemical_id),
    `Number of meta-analytic estimates` = sum(!is.na(ma_point_estimate))
  ) %>%
  rename(Outcome = health_outcome_type) %>%
  arrange(desc(`Number of meta-analyses`))

# Display table with bold caption
outcome_type_count %>%
  kable(caption = "Table: Health Outcomes in Meta-Analyses") %>%
  kable_styling(full_width = FALSE)
```

```{r, echo=FALSE}
## Count the number of occurrences of each health outcome type
otucome_group_count <- dat_quant %>%
  filter(!is.na(health_outcome_group) & health_outcome_group != "") %>% 
  group_by(health_outcome_group) %>%
  summarise(
    `Number of meta-analyses` = n_distinct(ma_id),
    `Number of health outcomes` = n_distinct(chemical_id),
    `Number of meta-analytic estimates` = sum(!is.na(ma_point_estimate))
  ) %>%
  rename("Outcome group" = health_outcome_group) %>%
  arrange(desc(`Number of meta-analyses`))

# Display table with bold caption
otucome_group_count %>%
  kable(caption = "Table: Health Outcomes Groups in Meta-Analyses") %>%
  kable_styling(full_width = FALSE)
```

```{r, include = FALSE}
# custom function
source(here("function", "custom_logOR.R"))

# get estimate for each cell
est_dat <- dat_quant %>% group_by(chemical_id, health_outcome_group) %>%
  mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  )) %>% 
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=10}
# traditional map with the number of study
est_dat$chemical_id <- as.factor(est_dat$chemical_id)

Box1_map1 <- ggplot(est_dat, aes(x = chemical_id, y = health_outcome_group, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Group") +
  scale_size(range = c(8,22)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of studies") + 
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title = element_text(size = 12, face = "bold")) 

Box1_map1

```

```{r,echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=10}
# traditional map with the number of effect size
Box1_map2 <- ggplot(est_dat, aes(x = chemical_id, y = health_outcome_group, size = n_es)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) + 
  labs(x = "PFAS", y = "Health Outcome Group") +
  scale_size(range=c(8,22)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal',  
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_es)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of effect sizes") +
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 12),
         axis.title = element_text(face = "bold", size = 12))

Box1_map2
```

-  A = Diseases related to pregnancy or childbirth
-  B = Neoplasms
-  C = Neurodevelopmental disorders
-  D = Endocrine diseases
-  E = Diseases of the circulatory system
-  F = Diseases related to the perinatal period

```{r, include=FALSE}
est_dat2 <- dat_quant %>%
  filter(health_outcome_group == "Pregnancy, childbirth or the puerperium")

est_dat2 <- est_dat2 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map1 <- ggplot(est_dat2, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme( axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_text(size = 12, face = "bold")) 

Box2_map1
```

```{r, include=FALSE}
est_dat3 <- dat_quant %>% 
  filter(health_outcome_group == "Neoplasms")

est_dat3 <- est_dat3 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map2 <- ggplot(est_dat3, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_blank()) 

Box2_map2
```

```{r, include=FALSE}
est_dat4 <- dat_quant %>% 
  filter(health_outcome_group == "Mental, behavioural or neurodevelopmental disorders")

est_dat4 <- est_dat4 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map3 <- ggplot(est_dat4, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_text(size = 12, face = "bold")) 

Box2_map3
```

```{r, include=FALSE}
est_dat5 <- dat_quant %>% 
  filter(health_outcome_group == "Endocrine, nutritional or metabolic diseases")

est_dat5 <- est_dat5 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map4 <- ggplot(est_dat5, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_blank()) 

Box2_map4
```

```{r, include=FALSE}
est_dat6 <- dat_quant %>% 
  filter(health_outcome_group == "Diseases of the circulatory system")

est_dat6 <- est_dat6 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map5 <- ggplot(est_dat6, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title = element_text(size = 12, face = "bold")) 

Box2_map5
```

```{r, include=FALSE}
est_dat7 <- dat_quant %>% 
  filter(health_outcome_group == "Certain conditions originating in the perinatal period")

est_dat7 <- est_dat7 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate_logOR(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map6 <- ggplot(est_dat7, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of studies") + 
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_text(size = 12, face = "bold"),
         axis.title.y = element_blank()) 

Box2_map6
```


```{r, echo=FALSE, out.height=1000, out.width=1000, fig.width=11, fig.height=12}
plot_grid(Box2_map1, Box2_map2, Box2_map3, Box2_map4, Box2_map5, Box2_map6, 
          labels = c('A','B','C','D','E','F'),
          label_size = 14,
          nrow = 3,
          ncol = 2)
```

# First Research Question

**Question:** How does exposure to per- and polyfluoroalkyl substances (PFAS) affect human health?

**Objective:** To evaluate the magnitude and variability of associations between PFAS exposure and adverse human health outcomes based on multiple meta-analyses.

## The Overall Result

Our meta-meta-analytic approach addressed heterogeneity at two levels. First, we modeled between-meta-analysis heterogeneity in reported effect sizes (logOR) using a multilevel meta-analytic model. This allowed us to partition the variance in outcomes across and within meta-analyses. Second, we meta-analyzed heterogeneity as the outcome by synthesizing the IÂ² values reported by the included meta-analyses. These were transformed into ln(H) to quantify and model differences in the internal heterogeneity of primary studies.

Random effect structure:

- **~1 | ma_id** introduces a random intercept for each meta-analysis. It acknowledges that different meta-analyses may have different baseline effects due to design, populations, etc.

- **~1 | ma_e_id** introduces a random intercept for each effect size estimate within a meta-analysis. It accounts for non-independence of estimates within the same meta-analysis.

```{r, results=FALSE}
VCV <- impute_covariance_matrix(vi = dat_quant$se^2,  
                                cluster = dat_quant$pair,
                                r = 0.5)

mod_overall <- rma.mv(yi = logOR,  
                        V = VCV, 
                        random = list(~1|ma_id, 
                                      ~1|ma_e_id), 
                        data = dat_quant,
                        test = "t")

I2_logOR <- orchaRd::i2_ml(mod_overall)
```


```{r, echo=FALSE}
#mod_overall <- robust(mod_overall, dat_quant$pair) #The robust() function computes robust standard errors that account for non-normality and/or heteroscedasticity in the residuals.
summary(mod_overall)
```

```{r, include=FALSE}
# Forest plot logOR

overall_plot_logOR <- dat_quant %>%
  mutate(
    OR = exp(logOR),
    OR_ci_lower = exp(l_ci_logOR),
    OR_ci_upper = exp(u_ci_logOR)
  )

overall_plot_logOR$ma_e_id <- factor(
  overall_plot_logOR$ma_e_id
)

overall_value_logOR <- data.frame(
  OR = exp(mod_overall$b[1]),
  ma_e_id = "Overall",
  OR_ci_lower = exp(mod_overall$ci.lb),
  OR_ci_upper = exp(mod_overall$ci.ub)
)

fp_OR <- ggplot(overall_plot_logOR, aes(x = OR, y = ma_e_id)) +
  geom_point(shape = 18, size = 4) +
  geom_errorbarh(aes(xmin = OR_ci_lower, xmax = OR_ci_upper),
                 height = 0.2) +
  geom_vline(xintercept = 1,  # Null effect for OR
             linetype = "dashed", 
             color = "red") +
  geom_point(data = overall_value_logOR,
             aes(x = OR, y = ma_e_id),
             shape = 23, size = 4, fill = "red") +
  geom_errorbarh(data = overall_value_logOR,
                 aes(xmin = OR_ci_lower, xmax = OR_ci_upper, y = ma_e_id),
                 height = 0.3, size = 1) +
  labs(x = "Odds Ratio (OR)", 
       y = "Meta-analytic estimate",
       title = "Forest Plot of Odds Ratios") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank()) +
  scale_y_discrete(limits = rev(c(levels(overall_plot_logOR$ma_e_id), "Overall")))

```


```{r, include=FALSE}
#Extracting data from the model
overall_results <- tibble(
  lnOR = as.numeric(mod_overall$b),
  lnOR_ci_lower = mod_overall$ci.lb,
  lnOR_ci_upper = mod_overall$ci.ub,
  lnOR_p_value = mod_overall$pval
)
```

```{r, results=FALSE}
# 1. Calculate HÂ², lnHÂ², and SElnH
dat_H2 <- dat_quant %>%
  mutate(n_ps_e = if_else(is.na(n_ps_e), n_ps, n_ps_e)) %>% #For each row, checks if n_ps_e (i.e., number of primary study estimates) is NA. If it is, replaces it with the value from n_ps (number of primary studies).
  filter(n_ps_e > 2) %>%  # Explicitly exclude cases where SElnH would be invalid
  mutate(
    I_squared = as.numeric(I_squared),
    # Calculate HÂ² from IÂ²
    H2 = 1 / (1 - (I_squared / 100)),
    lnH = log(sqrt(H2)),
    
    # Calculate SElnH
    k = n_ps_e, # number of effect sizes (primary study estimates)
    SElnH = sqrt((1 / (2 * (k - 2))) * (1 - (1 / (3 * (k - 2))^2))),

    # Calculate Confidence Intervals for lnH
    lnH_ci_lower = lnH - 1.96 * SElnH,
    lnH_ci_upper = lnH + 1.96 * SElnH
  ) %>% 
  filter(!is.infinite(lnH)) %>% # removing lnH = Inf (it happens when I-squared = 0)
  group_by(chemical_id) %>%
  filter(n_distinct(ma_e_id) > 1) %>% # at least 2 meta-analytic estimates
  ungroup() %>% 
  mutate(chemical_id = droplevels(factor(chemical_id)))

# Create the VCV matrix assuming rho = 0.5 for within-pair correlation
VCV_H2 <- impute_covariance_matrix(vi = dat_H2$SElnH^2,  
                                   cluster = dat_H2$pair,
                                   r = 0.5)
```


```{r, warning=FALSE}
mod_overall_H2 <- rma.mv(
  yi = lnH, 
  V = VCV_H2, 
  random = list(~1|ma_id,
                ~1|ma_e_id), 
  data = dat_H2,
  test = "t"
)

summary(mod_overall_H2)
```


```{r, include=FALSE}
# Forest plot lnH

dat_H2$ma_e_id <- factor(dat_H2$ma_e_id) 
dat_H2 <- dat_H2 %>% 
  mutate(
    # 1) Compute H2 and its CIs
     H2        = exp(2 * lnH),
     H2_lb     = exp(2 * lnH_ci_lower),
     H2_ub     = exp(2 * lnH_ci_upper),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100)),
    I2_se = (I2_ci_upper - I2_ci_lower) / (2 * 1.96)
  )

overall_value_I2 <- data.frame(
  I2           = pmin(100, pmax(0, (exp(2 * mod_overall_H2$b[1]) - 1)/exp(2 * mod_overall_H2$b[1])  * 100)),
  ma_e_id = "Overall",
  I2_ci_lower  = pmin(100, pmax(0, (exp(2 * mod_overall_H2$ci.lb) - 1)/exp(2 * mod_overall_H2$ci.lb) * 100)),
  I2_ci_upper  = pmin(100, pmax(0, (exp(2 * mod_overall_H2$ci.ub) - 1)/exp(2 * mod_overall_H2$ci.ub) * 100))
)
```


```{r, include=FALSE}
fp_lnH <- ggplot(dat_H2, aes(x = I2, y = ma_e_id)) +
  geom_point(shape = 18, size = 4) +  # Point estimates
  geom_errorbarh(aes(xmin = I2_ci_lower, xmax = I2_ci_upper), 
                 height = 0.2) +      # Confidence intervals
  geom_vline(xintercept = 50,           # Line at null effect
             linetype = "dashed", 
             color = "red") +
  geom_point(data = overall_value_I2,
             aes(x = I2, y = ma_e_id),
             shape = 23, size = 4, fill = "red") +
  geom_errorbarh(data = overall_value_I2,
                 aes(xmin = I2_ci_lower, xmax = I2_ci_upper, y = ma_e_id),
                 height = 0.3, size = 1) +
  labs(x = "I2", 
       y = "Meta-analytic estimates",
       title = "Forest Plot of Heterogeneity") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank()) + # Cleaner horizontal lines
  scale_y_discrete(limits = rev(c(levels(dat_H2$ma_e_id), "Overall")))
```

```{r, include=FALSE}
plot_grid(fp_OR, fp_lnH, 
          labels = c('A','B'),
          label_size = 14,
          nrow = 1,
          ncol = 2)
```

```{r, include=FALSE}
#Extracting data from the model
overall_results_H2 <- tibble(
  lnH = as.numeric(mod_overall_H2$b),
  lnH_ci_lower = mod_overall_H2$ci.lb,
  lnH_ci_upper = mod_overall_H2$ci.ub,
  lnH_p_value = mod_overall_H2$pval
) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * lnH_ci_lower),
    H2_ub     = exp(2 * lnH_ci_upper),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

I2_text <- paste0("IÂ² = ", round(overall_results_H2$I2, 1), 
                  "% [", round(overall_results_H2$I2_ci_lower, 1), 
                  "â€“", round(overall_results_H2$I2_ci_upper, 1), "%]")
```

```{r, include=FALSE}
overall_plot <- orchard_plot(
  object = mod_overall,
  group = "ma_id",
  xlab = "logOR",
  transfm = "none",
  trunk.size = 0.8,
  branch.size = 2.5,
  alpha = 1
) + 
  # Add faded red background for x < 0
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0, 
           fill = "green", alpha = 0.08) + 
  # Add faded green background for x > 0
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 0, ymax = Inf, 
           fill = "red", alpha = 0.08) + 
  annotate(geom = "text",
           x = 1.3,
           y = -1, 
           label = paste0("italic(I)^2 ~ logOR == ", round(I2_logOR[1],1)),
           size = 4,
           color ="black",
           parse = TRUE) +
  theme(
    legend.position.inside = c(0.05, 0.05),  # x, y coordinates relative to the plot (0 = left/bottom, 1 = right/top)
    legend.justification = c(0, 0),   # anchor the legend by its bottom-left corner
    legend.background = element_rect(fill = alpha("green", 0.001), color = NA),
    legend.key = element_rect(fill = "transparent")  # make individual legend keys blend in
  )

print(overall_plot)
```

```{r, include=FALSE}
I2_H2 <- orchaRd::i2_ml(mod_overall_H2)

overall_plot_H2 <- orchard_plot(
  object = mod_overall_H2,
  group = "ma_id",
  xlab = "lnH",
  transfm = "none",
  trunk.size = 0.8,
  branch.size = 2.5,
  alpha = 1
) + 
  # Add faded red background for x < 0
  # annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0.3466, 
  #          fill = "green", alpha = 0.08) + 
  # # Add faded green background for x > 0
  # annotate("rect", xmin = -Inf, xmax = Inf, ymin = 0.3466, ymax = Inf, 
  #          fill = "red", alpha = 0.08) + 
  annotate(geom = "text",
           x = 1.3,
           y = 2, 
           label = paste0("italic(I)^2 ~ lnH == ", round(I2_H2[1],1)),
           size = 4,
           color ="black",
           parse = TRUE) +
  theme(
    legend.position.inside = c(0.55, 0.05),  # x, y coordinates relative to the plot (0 = left/bottom, 1 = right/top)
    legend.justification = c(0, 0),   # anchor the legend by its bottom-left corner
    legend.background = element_rect(fill = alpha("green", 0.001), color = NA),
    legend.key = element_rect(fill = "transparent")  # make individual legend keys blend in
  ) + 
  scale_y_continuous(limits = c(0,1))
 

print(overall_plot_H2)
```

```{r, include=FALSE, out.height=1000, out.width=1000, fig.width=11, fig.height=12}
plot_grid(overall_plot, overall_plot_H2, 
          labels = c('A','B'),
          label_size = 14,
          nrow = 2,
          ncol = 1)
```

```{r, include=FALSE, eval=FALSE}
ggsave(here("figs","fig1.png"),
       width = 8,
       height = 6)
```


```{r, include=FALSE}
merged_overall_results <- bind_cols(overall_results, overall_results_H2)

ggplot(merged_overall_results, aes(x = lnOR, y = I2)) +
  # Horizontal error bars (for lnOR)
  geom_errorbarh(aes(xmin = lnOR_ci_lower, xmax = lnOR_ci_upper), height = 2, alpha = 0.5) +
  # Vertical error bars (for I2)
  geom_errorbar(aes(ymin = I2_ci_lower, ymax = I2_ci_upper), width = 0.01, alpha = 0.5) +
  # Point
  geom_point(size = 5) +
  # Reference lines
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  # Axes
  scale_x_continuous(limits = c(-0.1, 0.1), breaks = seq(-0.1, 0.1, by = 0.1)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  # Labels
  labs(
    x = "Effect size (logOR)",
    y = "Heterogeneity (I\u00b2 %)"
  ) +
  theme_minimal(base_size = 13)
```


```{r, include=FALSE}
# Prepare merged dataset for plotting (merge OR and I2 data by ma_e_id)
galaxy_data <- dat_quant %>%
  mutate(
    OR = exp(logOR),
    OR_ci_lower = exp(l_ci_logOR),
    OR_ci_upper = exp(u_ci_logOR)
  ) %>%
  left_join(
    dat_H2 %>% select(ma_e_id, I2, I2_ci_lower, I2_ci_upper, I2_se),
    by = "ma_e_id"
  ) %>% 
  filter(!is.na(I2) & !is.na(OR))

# Prepare overall result
overall_point <- data.frame(
  OR = overall_value_logOR$OR,
  OR_ci_lower = overall_value_logOR$OR_ci_lower,
  OR_ci_upper = overall_value_logOR$OR_ci_upper,
  I2 = overall_value_I2$I2,
  I2_ci_lower = overall_value_I2$I2_ci_lower,
  I2_ci_upper = overall_value_I2$I2_ci_upper,
  ma_e_id = "Overall"
)

# Calculations for prediction intervals
# Extract model components
mu <- as.numeric(mod_overall$b)  # overall effect size (log OR)
se <- mod_overall$se             # standard error
tau2 <- sum(mod_overall$sigma2)  # total between-study variance
k <- length(mod_overall$yi)      # number of effect sizes
df <- k - length(mod_overall$sigma2)  # conservative degrees of freedom

# Calculate t critical value
t_crit <- qt(0.975, df = df)

# Calculate prediction interval (on log scale)
pred_lower <- mu - t_crit * sqrt(tau2 + se^2)
pred_upper <- mu + t_crit * sqrt(tau2 + se^2)

# Convert to OR scale
pred_int <- data.frame(
  OR_pred_lower = exp(pred_lower),
  OR_pred_upper = exp(pred_upper),
  OR = overall_point$OR
)

```


```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
galaxy_data$col <- rep("col", nrow(galaxy_data))
# Plot
galaxy_plot <- ggplot(galaxy_data, aes(x = OR, y = I2, size = 1/se)) +
  # Individual points (no error bars)
  geom_point(aes(fill = col, color = col), shape = 21, alpha = 0.5) +

  # Overall horizontal error bar (for OR)
  geom_errorbarh(
    data = overall_point,
    aes(xmin = OR_ci_lower, xmax = OR_ci_upper),
    height = 2, 
    size = 1.3
  ) +
  
  geom_errorbarh(
    data = pred_int,
    aes(xmin = OR_pred_lower, xmax = OR_pred_upper, y = overall_point$I2),
    height = 1.5,
    color = "black",
    size = 0.5,
    linetype = "solid"
  ) +
  
  # Overall vertical error bar (for I2)
  geom_errorbar(
    data = overall_point,
    aes(ymin = I2_ci_lower, ymax = I2_ci_upper),
    width = 0.03, 
    size = 1.3
  ) +
  
  # Overall point (diamond)
  geom_point(
    data = overall_point,
    aes(x = OR, y = I2),
    shape = 23,  # Diamond shape
    size = 3,
    fill = "firebrick",
    color = "black",
    stroke = 1.2
  ) +
  
  scale_size(range = c(3, 12)) +
  
  annotate("text", x = 0, y = 85, label = "lack of association\nlow consistency", hjust = 0, size = 4.5) +
  annotate("text", x = 1.55, y = 85, label = "positive association\nlow consistency", hjust = 0, size = 4.5) +
  annotate("text", x = 1.55, y = 15, label = "positive association\nhigh consistency", hjust = 0, size = 4.5) +
  annotate("text", x = 0, y = 15, label = "lack of association\nhigh consistency", hjust = 0, size = 4.5) +

  # Reference lines
  geom_vline(xintercept = 1, linetype = "dashed" , color = "firebrick") +
  geom_vline(xintercept = 0.5, linetype = "dashed", color = "grey40") +
  geom_vline(xintercept = 1.5, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 25, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 75, linetype = "dashed", color = "grey40") +

  # Axes
  scale_x_continuous(limits = c(0, 2), breaks = seq(0, 2, by = 0.5)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  
  scale_color_manual(values = "grey50") +
  scale_fill_manual(values = "grey50") +
  guides(fill = "none", color = "none") +

  # Labels
  labs(
    x = "Odds Ratio",
    y = "Heterogeneity (I\u00b2 %)",
    size = "Precision (1/SE):"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 12),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(color = "black", fill = NA, size = 0.8),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggMarginal(galaxy_plot , groupColour = T, groupFill = T, type = "histogram")
```

```{r, include=FALSE, eval=FALSE}
ggsave(here("figs","fig_overall.png"),
       width = 9, height = 7, bg = "white", dpi = 300)
```

**Figure 1. Overall association and consistency of PFAS-related adverse health outcomes across meta-analyses.**
*Each bubble represents a meta-analytic effect size (n = 207) from 23 published meta-analyses on PFAS exposure and human health outcomes. The x-axis shows the pooled Odds Ratio (OR), where values above 1 indicate increased odds of adverse outcomes. The y-axis depicts heterogeneity (IÂ²), representing the percentage of variation across studies not due to chance. Bubble sizes are scaled by precision (inverse of standard error). The red diamond indicates the overall pooled estimate from a meta-meta-analysis, with horizontal and vertical error bars showing its 95% confidence intervals for OR and IÂ², respectively. Grey dashed and solid lines indicate thresholds for heterogeneity (25% = low, 50% = medium, 75% = high). Quadrant annotations help interpret the strength and consistency of associations.*

## Summary Results RQ1

**1)**  Across all meta-analyses included in our synthesis, exposure to PFAS was associated with a statistically significant increase in the odds of experiencing adverse health outcomes. On average, PFAS exposure was linked to a 5.8% increase in risk (95% CI: 3.1%â€“8.6%), suggesting a modest but measurable impact on human health. We observed substantial overall heterogeneity (IÂ² logOR= 86.9%), with the majority (71.7%) attributable to differences among effect sizes within individual meta-analyses. This suggests that variation in reported associations is driven more by heterogeneity in primary study findings than by systematic differences across meta-analyses.

**2)**  The average reported heterogeneity across PFAS-related meta-analyses was moderate (average lnH = 0.53 = IÂ² â‰ˆ 42%), but the amount of heterogeneity in these heterogeneity estimates themselves was substantial (IÂ² lnH â‰ˆ 89%). Approximately half of this variance (49%) was attributable to differences between meta-analyses, suggesting that some research syntheses consistently report more heterogeneity than others


# Second Research Question

## Chemicals

**Question:** What individual PFAS are significantly associated with adverse health outcomes?

To evaluate chemical-specific associations, I conducted separate multilevel meta-analyses for each chemical. First, I identified all unique chemicals in the dataset and then, for each chemical, filtered the data accordingly. I run the model when at least two meta-analytic estimates contributed data for a given chemical. Using a multilevel meta-analytic model (random effects: meta-analysis ID and effect size ID), I estimated the pooled log odds ratio (logOR), its confidence interval, and p-value. Results were stored in a unified table. If a model failed to converge or insufficient data were available, missing values (NA) were recorded instead. This approach allowed a standardized and robust summary of the strength and variability of associations for each individual chemical.

```{r, results=FALSE, warning=FALSE}
# Get a list of chemicals
chemicals <- unique(dat_quant$chemical_id)

# Run separate meta-analyses for each chemical_id
results_list <- map_dfr(chemicals, function(chem) {
  dat_sub <- dat_quant %>% filter(chemical_id == chem)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) {  # Require at least 2 meta-analytic estimates
    tryCatch({
      # Calculate VCV matrix for this subset
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = logOR,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        chemical_id = chem,
        logOR = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(chemical_id = chem, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
     tibble(chemical_id = chem, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
           #tau2 = NA, I2 = NA, CV = NA,
           k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE, warning=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
plot_data_chemical <- results_list %>% 
  filter(!is.na(logOR)) %>% 
  arrange(logOR)

forest_plot_chemical <- ggplot(plot_data_chemical, aes(y = reorder(chemical_id, logOR), x = logOR)) +
  geom_point(aes(size = k), 
             color = ifelse(plot_data_chemical$pval > 0.05, "grey", "black"),
             alpha = 1) +
  scale_size(range = c(5, 13)) +
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub),
                 height = 0.2,
                 alpha = ifelse(plot_data_chemical$pval > 0.05, 0.6, 1)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = min(ci.lb, na.rm = TRUE) - 0.2),
            hjust = 0, size = 5,
            fontface = ifelse(plot_data_chemical$pval < 0.05, "bold", "plain")) +
  xlab("logOR") +
  ylab("PFAS") +
  theme_minimal() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
        axis.text.x = element_text(size = 15))

forest_plot_chemical
```

```{r, results=FALSE, warning=FALSE}
# Run separate meta-analyses for each chemical_id
results_list2 <- map_dfr(chemicals, function(chem) {
  dat_sub <- dat_H2 %>% filter(chemical_id == chem)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) {  # Require at least 2 meta-analytic estimates
    tryCatch({
      # Calculate VCV matrix for this subset
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = lnH,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        chemical_id = chem,
        lnH = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(chemical_id = chem, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
     tibble(chemical_id = chem, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
           #tau2 = NA, I2 = NA, CV = NA,
           k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE}
custom_order <- c("PFDoDA", "PFUnDA", "PFHpA", "PFDA", "PFAS", "PFNA", "PFOS", "PFHxS", "PFOA")

plot_data_chemical_H2 <- results_list2 %>% 
  filter(!is.na(lnH)) %>% 
  mutate(chemical_id = factor(chemical_id, levels = custom_order)) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * ci.lb),
    H2_ub     = exp(2 * ci.ub),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

plot_data_chemical_merged <- left_join(plot_data_chemical, plot_data_chemical_H2 %>% 
                                         select(chemical_id, I2, I2_ci_lower, I2_ci_upper), 
                                       by = "chemical_id") %>% 
  mutate(
    OR = exp(logOR),
    OR_ci_lower = exp(ci.lb),
    OR_ci_upper = exp(ci.ub)
  )
```


```{r, include=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
forest_plot_chemical <- forest_plot_chemical +
  geom_text(data = plot_data_chemical_merged,
            aes(label = paste0(
              "IÂ² = ", round(I2, 1), "% [", 
              round(I2_ci_lower, 1), "â€“", 
              round(I2_ci_upper, 1), "]")),
            hjust = -0.2, vjust = -0.7, size = 4.5)


forest_plot_chemical
```

```{r, echo=FALSE}
galaxy_chemicals <- ggplot(plot_data_chemical_merged, aes(x = OR, y = I2, label = chemical_id, size = k, color = pval < 0.05 | pval < 0.05)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(size = 6, max.overlaps = Inf, box.padding = 1, min.segment.length = 0) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "firebrick") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 25, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 75, linetype = "dashed", color = "grey40") +
  
  # Quadrant text
  # annotate("text", x = -0.095, y = 95, label = "lack of association\nlow consistency", hjust = 0, size = 4) +
  # annotate("text", x = 0.06, y = 95, label = "positive association\nlow consistency", hjust = 0, size = 4) +
  # annotate("text", x = 0.06, y = 3, label = "positive association\nhigh consistency", hjust = 0, size = 4) +
  # annotate("text", x = -0.095, y = 3, label = "lack of association\nhigh consistency", hjust = 0, size = 4) +

  scale_color_manual(values = c("grey50", "firebrick"), labels = c("No", "Yes")) +
  scale_size(range = c(8, 13)) +
  scale_x_continuous(limits = c(0.85, 1.15), breaks = seq(0.85, 1.15, by = 0.15)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  labs(
    x = "Effect size (OR)",
    y = "Heterogeneity (I\u00b2 %)",
    color = "OR p < 0.05:",
    size = "k:"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "none",
    legend.box = "vertical",
    legend.margin = margin(),
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 0.6),
    axis.title = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 12)
  ) +
  guides(
    color = "none",
    size = guide_legend(
    override.aes = list(
      shape = 21,         
      fill = NA,     
      color = "grey50",    
      alpha = 1           
    ),
    order = 2
  )
  )
```

```{r, include=FALSE, eval=FALSE}
ggsave(here("figs","fig2.png"),
       width = 8,
       height = 6)
```

*Each estimate is based on a separate meta-analysis for each PFAS chemical.*

## Health Outcome Group

The meta-analyses included in our study pooled data from studies on various types of adverse health outcomes. We grouped these health types into groups: the higher grouping level according to the ICD-11 for Mortality and Morbidity Statistics.

**Question:** What groups of adverse health outcome are significantly associated with PFAS exposure?

Similarly to the previous code, I ran separate multilevel meta-analyses for each health outcome group to assess associations by health outcome. For each group, I filtered the dataset and fitted a random-effects model (with random intercepts for meta-analysis ID and effect size ID) when at least two meta-analytic estimates contributed data. For each health outcome, I estimated the pooled log odds ratio (logOR), its confidence interval, and p-value, recording NA values if model fitting was not possible.

```{r, include=FALSE}
dat_quant$health_outcome_group <- as.factor(dat_quant$health_outcome_group)

dat_quant <- dat_quant %>% 
mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  ))
```

```{r, results=FALSE, warning=FALSE}
# Get a list of outcome groups
outcomes <- unique(dat_quant$health_outcome_group)

# Loop over each health outcome group
results_health <- map_dfr(outcomes, function(outcome) {
  dat_sub <- dat_quant %>% filter(health_outcome_group == outcome)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) { # requires at least 2 meta-analytic estimates
    tryCatch({
      
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = logOR,  
                      V = se^2,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        health_outcome_group = outcome,
        logOR = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(health_outcome_group = outcome, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
    tibble(health_outcome_group = outcome, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```


```{r, include=FALSE, warning=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
plot_data_health <- results_health %>% 
  filter(!is.na(logOR)) %>% 
  arrange(logOR) %>% 
  filter(n > 1)

forest_plot_health <- ggplot(plot_data_health, aes(y = reorder(health_outcome_group, logOR), x = logOR)) +
  geom_point(aes(size = k), 
             color = ifelse(plot_data_health$pval > 0.05, "grey", "black"),
             alpha = 1) +
  scale_size(range = c(5, 13)) +
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub),
                 height = 0.2,
                 alpha = ifelse(plot_data_health$pval > 0.05, 0.6, 1)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = min(ci.lb, na.rm = TRUE) - 0.2),
            hjust = 0, size = 5,
            fontface = ifelse(plot_data_health$pval < 0.05, "bold", "plain")) +
  xlab("logOR") +
  ylab("Health Outcome Group") +
  theme_minimal() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
        axis.text.x = element_text(size = 15))

forest_plot_health
```


```{r, results=FALSE, warning=FALSE}
dat_H2 <- dat_H2 %>% 
mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  ))

# Get a list of outcome groups
outcomes <- unique(dat_H2$health_outcome_group)

# Loop over each health outcome group
results_health_H2 <- map_dfr(outcomes, function(outcome) {
  dat_sub <- dat_H2 %>% filter(health_outcome_group == outcome)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) { # requires at least 2 meta-analytic estimates
    tryCatch({
      
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = lnH,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        health_outcome_group = outcome,
        lnH = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(health_outcome_group = outcome, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
    tibble(health_outcome_group = outcome, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE}
custom_order <- c("Neurodevelopmental\ndisorders", "Neoplasms", "Perinatal period", "Pregnancy or\nchildbirth", "Diseases of the\ncirculatory system", "Endocrine diseases")

plot_data_health_H2 <- results_health_H2 %>% 
  filter(!is.na(lnH)) %>% 
  mutate(health_outcome_group = factor(health_outcome_group, levels = custom_order)) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * ci.lb),
    H2_ub     = exp(2 * ci.ub),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

plot_data_health_merged <- left_join(plot_data_health, plot_data_health_H2 %>% 
                                         select(health_outcome_group, I2, I2_ci_lower, I2_ci_upper), 
                                       by = "health_outcome_group") %>% 
  mutate(
    OR = exp(logOR),
    OR_ci_lower = exp(ci.lb),
    OR_ci_upper = exp(ci.ub)
  )
```


```{r, include=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
forest_plot_health2 <- forest_plot_health +
  geom_text(data = plot_data_health_merged,
            aes(label = paste0(
              "IÂ² = ", round(I2, 1), "% [", 
              round(I2_ci_lower, 1), "â€“", 
              round(I2_ci_upper, 1), "]")),
            hjust = -0.2, vjust = -0.7, size = 4.5)


forest_plot_health2
```

```{r, echo=FALSE}
galaxy_health <- ggplot(plot_data_health_merged, aes(x = OR, y = I2, label = health_outcome_group, size = k, color = pval < 0.05 | pval < 0.05)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(size = 6, max.overlaps = Inf, box.padding = 1, min.segment.length = 0) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "firebrick") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 25, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 75, linetype = "dashed", color = "grey40") +
  
  # Quadrant text
  # annotate("text", x = -0.095, y = 95, label = "lack of association\nlow consistency", hjust = 0, size = 4) +
  # annotate("text", x = 0.06, y = 95, label = "positive association\nlow consistency", hjust = 0, size = 4) +
  # annotate("text", x = 0.06, y = 3, label = "positive association\nhigh consistency", hjust = 0, size = 4) +
  # annotate("text", x = -0.095, y = 3, label = "lack of association\nhigh consistency", hjust = 0, size = 4) +

  scale_color_manual(values = c("grey50", "firebrick"), labels = c("No", "Yes")) +
  scale_size(range = c(8, 13)) +
  scale_x_continuous(limits = c(0.85, 1.15), breaks = seq(0.85, 1.15, by = 0.15)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  labs(
    x = "Odds Ratio",
    y = "Heterogeneity (I\u00b2 %)",
    color = "OR p < 0.05:",
    size = "k:"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.margin = margin(),
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 0.6),
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 14),
    axis.text = element_text(size = 12)
  ) +
  guides(
    color = "none",
    size = guide_legend(
    override.aes = list(
      shape = 21,         
      fill = NA,     
      color = "grey50",    
      alpha = 1           
    ),
    order = 2
  )
  )
```

```{r, echo=FALSE}
combined_plot <- plot_grid(galaxy_chemicals, galaxy_health, 
                           labels = c('A','B'),
                           label_size = 14,
                           nrow = 2,
                           #align = "v",
                           rel_heights = c(1, 1.4))

# Add a single y-axis label
ggdraw() + 
  draw_label("Heterogeneity (I\u00b2 %)",
             x = 0.02, 
             y = 0.6, 
             angle = 90,
             vjust = 0.5, 
             size = 14) +
  draw_plot(combined_plot,
            x = 0.05, 
            width = 0.95)
```

```{r, include=FALSE, eval=FALSE}
ggsave(here("figs","fig3.png"),
       width = 9, height = 10, bg = "white", dpi = 300)
```

## Summary Results

**1)**  

-  **PFOS** and **PFOA** both show statistically significant positive associations (logOR = 0.061 and 0.073, respectively), meaning exposure is associated with increased odds of adverse outcomes. However, both also have moderate-to-high IÂ² values (around 63â€“69%), suggesting that although the associations are consistent enough to reach statistical significance, there is notable heterogeneity in the size of the effect across meta-analyses.

-  **PFHxS** and **PFNA** have positive but non-significant logORs and similarly high IÂ² values (~62%), implying inconsistent evidence. The direction is generally toward harm, but effect sizes vary too much across studies to confirm a reliable association.

-  **PFUnDA** and **PFDA** have very low IÂ² values (~14%) and small, non-significant logORs, suggesting high consistency, but no compelling evidence of a harmful effect. This could imply a genuine lack of association or uniformly small effects across studies.

-  **PFDoDA** and **PFHpA** show near-zero or slightly negative logORs and moderate IÂ² values (~35â€“46%), indicating modest inconsistency, but again no meaningful association with health outcomes.

-  The **PFAS** (unspecified mix) group shows a near-zero, non-significant logOR and very high heterogeneity (IÂ² = 69.8%), implying that the mixed results likely reflect true variability across the included studies rather than random error.

**2)**  

-  **Diseases of the circulatory system**: Strongest and most consistent association: PFAS exposure is associated with a statistically significant increase in odds (logOR = 0.084). While heterogeneity is moderate-to-high (IÂ² = 67.2%), the tight confidence interval and high precision suggest a fairly robust relationship despite study-level differences.

-  **Pregnancy, childbirth or the puerperium**: A significant but smaller effect (logOR = 0.049) with low heterogeneity (IÂ² = 19.4%). This implies a consistent and reliable association, suggesting that even small effects are replicable across studies.

-  **Perinatal period**: A positive but non-significant effect (logOR = 0.041) with low-to-moderate heterogeneity (IÂ² = 32.1%). Results are fairly consistent, but the effect may be small or diluted by study design variation.

-  **Endocrine diseases**: A relatively large but non-significant effect (logOR = 0.101) paired with moderate heterogeneity (IÂ² = 54.4%). This combination implies uncertainty and variation across studies â€” some may show strong effects, others null or opposite. More research is likely needed.

-  **Neoplasms**: Shows low, non-significant effect (logOR = 0.028) but very high heterogeneity (IÂ² = 92.2%). This suggests results are highly inconsistent, and the small average effect likely masks large between-study variation, possibly due to differences in cancer types, latency periods, or exposure metrics.

-  **Neurodevelopmental disorders**: No evidence of association (logOR ~ 0) with moderate heterogeneity (IÂ² = 50.5%), suggesting that effects vary somewhat across studies, but overall there's no clear or consistent signal of harm.

# Third Research Question

**Question:** What are the significant associations between individual PFAS and specific health outcomes, and how strong are these correlations?

**Objective:** To determine significant PFAS-health outcome correlations and assess the strength of these relationships.

```{r, include=FALSE, out.height=600, out.width=1000, fig.width=10, fig.height=7}
est_dat <- est_dat %>%
  filter(n_studies > 1)

# Plot
ggplot(est_dat, aes(x = chemical_id, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
  geom_point(aes(color = pval < 0.05), size = 2.5) +
  geom_errorbar(aes(color = pval < 0.05), width = 0.2) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "black"), guide = "none") +
  facet_wrap(~ health_outcome_group, scales = "free_y") +
  labs(title = "Estimated Interaction Effects",
       x = "PFAS",
       y = "Log Odds Ratio (logOR)") +
  theme_minimal(base_size = 12) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(
    plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "none"
  )
```



```{r, include = FALSE}
# custom function
source(here("function", "custom_lnH.R"))

# get estimate for each cell
est_dat_lnH <- dat_H2 %>% group_by(chemical_id, health_outcome_group) %>%
  mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  )) %>% 
  group_modify(~ custom_meta_aggregate_lnH(.x, rho = 0.5)) %>% ungroup() %>%
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * ci.lb_lnH),
    H2_ub     = exp(2 * ci.ub_lnH),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

est_dat_merged <- merge(est_dat, est_dat_lnH, by = c("chemical_id", "health_outcome_group"))
```

```{r}
result_table <- est_dat_merged %>%
  mutate(
    # Create the "Chemical - outcome pair" column
    `Chemical-outcome pair` = paste(chemical_id, "-", health_outcome_group),
    
    # Format the odds ratio and 95% CI (rounded to 2 decimal places)
    `OR [95% CI]` = sprintf(
      "%.2f [%.2f to %.2f]", 
      exp(estimate), 
      exp(ci.lb), 
      exp(ci.ub)
    ),
    
    `IÂ²% [95% CI]` = sprintf(
      "%.1f [%.1f to %.1f]", 
      I2, 
      I2_ci_lower, 
      I2_ci_upper
      ),
    
    # Format the p-value (rounded to 3 decimal places)
    `p value` = format.pval(pval, digits = 3, eps = 0.001)
  ) %>%
  
  # Select only the columns we want in the final table
  select(
    `Chemical-outcome pair`, 
    `OR [95% CI]`, 
    `IÂ²% [95% CI]`,
    `p value`
  )

# Convert to a flextable
ft <- flextable(result_table) %>%
  theme_zebra() %>%  # Optional: Adds alternating row colors
  autofit()         # Adjusts column widths automatically

# Save to Word
save_as_docx(
  ft, 
  path = here("tabs", "PFAS_Health_Outcomes_Table.docx")
)
```


```{r, echo=FALSE, out.height=1200, out.width=1000, fig.width=10, fig.height=10}
ggplot(est_dat_merged, aes(x = estimate, y = I2, label = chemical_id, size = n_es, color = pval < 0.05)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(size = 4, max.overlaps = Inf, box.padding = 1, min.segment.length = 0) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  # annotate("text", x = -0.095, y = 95, label = "lack of association\nlow consistency", hjust = 0, size = 3) +
  # annotate("text", x = 0.06, y = 95, label = "positive association\nlow consistency", hjust = 0, size = 3) +
  # annotate("text", x = 0.06, y = 3, label = "positive association\nhigh consistency", hjust = 0, size = 3) +
  # annotate("text", x = -0.095, y = 3, label = "lack of association\nhigh consistency", hjust = 0, size = 3) +
  scale_color_manual(values = c("grey50", "firebrick"), labels = c("No", "Yes")) +
  scale_size(range = c(3, 12)) +
  scale_x_continuous(limits = c(-0.4, 0.4), breaks = seq(-0.4, 0.4, by = 0.2)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  labs(
    x = "Effect size (logOR)",
    y = "Heterogeneity (IÂ² %)",
    color = "logOR p < 0.05:",
    size = "k:"
  ) +
  facet_wrap(~ health_outcome_group, scales = "fixed", ncol = 2) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.margin = margin(),
    panel.grid = element_blank(),
    strip.text = element_text(face = "bold", size = 11)
  ) +
  guides(
    color = "none",
    size = guide_legend(override.aes = list(color = "grey50"), order = 2)
  )
```

```{r, include=FALSE, eval=FALSE}
ggsave(here("figs","fig4.png"),
       width = 7,
       height = 10)
```

## Summary Results RQ3

**1)**  The following combinations of PFAS-health outcomes showed significant associations: 

-  PFNA - Diseases related to the perinatal period:
   estimate = 0.123, CI = [ 0.017, 0.228], p-val = 0.0406, n = 3, k = 4.
-  PFHxS - Diseases of the circulatory system:
   estimate = 0.032, CI = [0.016, 0.048], p-val = 0.0189, n = 3, k = 5.
-  PFNA - Diseases of the circulatory system:
   estimate = 0.093, CI = [0.009, 0.177], p-val = 0.0421, n = 3, k = 5.
-  PFOA - Diseases of the circulatory system:
   estimate = 0.131, CI = [0.075, 0.186], p-val = 0.0134, n = 3, k = 5.
-  PFOS - Diseases of the circulatory system:
   estimate = 0.172, CI = [0.038, 0.305], p-val = 0.0333, n = 3, k = 5.
-  PFUnDA - Diseases related to pregnancy or childbirth:
   estimate = -0.136, CI = [-0.229, -0.043], p-val = 0.0263, n = 3, k = 4.


# Sensitivity Analysis

## Metaregressions

Here we run a classic uni-moderator meta-regression analysis to test the robustness of our subgroup analysis:

```{r, include=FALSE}
dat_quant$chemical_id <- as.factor(dat_quant$chemical_id)
```

```{r, results=FALSE}
mod2 <- rma.mv(yi = logOR,
               V = VCV,
               mods = ~ chemical_id -1,
               random = list(~1|ma_id,
                             ~1|ma_e_id),
               test = "t",
               sparse = T,
               data = dat_quant,
               control = list(iter.max = 1000,
                              rel.tol = 1e-8))

summary(mod2)
```

```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
r2_mod2 <- r2_ml(mod2, dat_quant)

k_n_data <- dat_quant %>% 
  group_by(chemical_id) %>%
  arrange(chemical_id) %>% 
  summarise(k = n(), n = length(unique(ma_id)))

res_tab1 <- broom::tidy(mod2)
res_tab1$ci.lb <- mod2$ci.lb
res_tab1$ci.ub <- mod2$ci.ub
res_tab1$pval <-mod2$pval
res_tab1 <- res_tab1 %>% 
  mutate(
    chemical_id = str_remove(term, "^chemical_id"),  # Remove 'Pchemical_id: ' prefix
  ) %>% 
  arrange(chemical_id)

res_tab1 <- res_tab1 %>% 
  left_join(k_n_data, by = "chemical_id")

# Prepare the data for plotting and order chemical_id by estimate value
plot_data1 <- res_tab1 %>%
  as.data.frame() %>% 
  filter(n > 1) %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot1 <- ggplot(plot_data1, aes(y = reorder(chemical_id, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data1$pval > 0.05, "grey", "black"), 
             alpha = 1) +  # Add transparency for better visibility
  scale_size(range = c(5, 13)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data1$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = - 0.3),
            hjust = 0, size = 5, # Add k values as text next to the points
            fontface = ifelse(plot_data1$pval < 0.05, "bold", "plain")) + 
  xlab("logOR") +
  ylab("PFAS") +
  #ggtitle("B") +
  theme_minimal() +  # Use a minimal theme
  annotate(geom = "text",
           x = -0.15,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_mod2[1],4)),
           color ="black",
           parse = TRUE, 
           size = 5) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
         plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
       axis.text.x = element_text(size = 15)) # +
   # scale_x_break(c(4, 6)) +
   # scale_x_continuous(breaks = seq(0, 4, by = 1), limits = c(-0.21, 4))

forest_plot1
```

- Now we do the same but using health outcome group as moderator.

```{r, results=FALSE}
mod4 <- rma.mv(yi = logOR,  
                  V = VCV,
                  mods = ~ health_outcome_group -1,
                   random = list(~1|ma_id,
                                 ~1|ma_e_id),
                   test = "t",
                   sparse = T,
                   data = dat_quant,
                   control = list(iter.max = 1000, 
                                  rel.tol = 1e-8))

summary(mod4)
```

```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
r2_mod4 <- r2_ml(mod4, dat_quant)

k_n_data3 <- dat_quant %>% 
  group_by(health_outcome_group) %>%
  arrange(health_outcome_group) %>% 
  summarise(k = n(), n = length(unique(ma_id)))

res_tab3 <- broom::tidy(mod4)
res_tab3$ci.lb <- mod4$ci.lb
res_tab3$ci.ub <- mod4$ci.ub
res_tab3$pval <- mod4$pval
res_tab3 <- res_tab3 %>% 
  mutate(
    health_outcome_group = str_remove(term, "^health_outcome_group")  # Remove 'health_outcome_group ' prefix
  ) %>% 
  arrange(health_outcome_group)

res_tab3 <- res_tab3 %>%
  left_join(k_n_data3, by = "health_outcome_group")

# Prepare the data for plotting and order health_outcome_group by estimate value
plot_data3 <- res_tab3 %>%
  as.data.frame() %>% 
  #filter(k > 1) %>% 
  filter(n > 1) %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot3 <- ggplot(plot_data3, aes(y = reorder(health_outcome_group, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data3$pval > 0.05, "grey", "black"),
             alpha = 1) +  # Add transparency for better visibility 
  scale_size(range = c(5, 13)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data3$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = - 0.3),
            hjust = 0, size = 5, # Add k values as text next to the points
            fontface = ifelse(plot_data3$pval < 0.05, "bold", "plain")) + 
  xlab("logOR") +
  ylab("Health Outcome Group") +
  ggtitle("B") +
  theme_minimal() +  
  annotate(geom = "text",
           x = -0.15,
           y = 5, 
           label = paste0("italic(R)^{2} == ", round(r2_mod4[1],4)),
           color ="black",
           parse = TRUE, 
           size = 5) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
         plot.title = element_text(face = "bold", size = 18),
       legend.title = element_text(size = 16),
        legend.text = element_text(size = 15),
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        axis.text.y = element_text(size = 17),
       axis.text.x = element_text(size = 17)) #+  
   #scale_x_break(c(4, 6)) +
   #scale_x_continuous(breaks = seq(0, 4, by = 1), limits = c(-0.21, 4))
  
forest_plot3
```

## Different VCV

cluster VCV over chemical and over health outcome for sensitivity analysis and check convergence of models

