---
title: "Analysis Code"
author: "Lorenzo Ricolfi"
output:
  html_document:
    code_folding: show
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    toc_depth: 3
    number_sections: no
    theme: cerulean
  pdf_document:
    toc: yes
    toc_depth: '2'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Link to the pre-registered Research Protocol: https://osf.io/dc5mx

Review questions:

1.	How does exposure to per- and polyfluoroalkyl substances (PFAS) affect human health?
2.	Which PFAS are linked to adverse health effects, and what are the associated health outcomes?
3.	What are the significant associations between individual PFAS and specific health outcomes, and how strong are these correlations?
4.	How consistent are the findings regarding PFAS-health outcome associations across different meta-analyses?

Objectives:

1.	To evaluate the magnitude and variability of associations between PFAS exposure and human health outcomes based on multiple meta-analyses.
2.	To identify specific PFAS (e.g., perfluorooctane sulfonate (PFOS)) significantly associated with adverse health effects and the specific health outcomes impacted.
3.	To determine significant PFAS-health outcome correlations and assess the strength of these relationships.
4.	To assess the consistency of findings from objectives 2 and 3 by analyzing the heterogeneity across meta-analyses.

In this analysis workflow, we answer to research question 4 within research questions 1, 2, and 3. In other words, every time we assess the magnitude of results we also assess the consistency of results.

# Packages

```{r, results=FALSE, warning=FALSE, message=FALSE}
# tidy
# rm(list=ls())
# Install and load necessary library
pacman::p_load(tidyr,
               dplyr,
               here,
               ggplot2,
               gridExtra,
               metafor,
               orchaRd,
               stringr,
               cowplot,
               purrr,
               broom,
               clubSandwich,
               ggrepel
               )       
```

# Data loading, wrangling and cleaning

```{r, results=FALSE}
# Load the 'ma_details' and 'ma_e_details' datasets from the 'data' folder using the 'here' package
ma_details <- read.csv(here("data/ma_details.csv"))
ma_e_details <- read.csv(here("data/ma_e_details.csv"))

# Creating a data set for qualitative synthesis (i.e., dat_qual)
# Filter and clean 'ma_e_details', then join with 'ma_details'
dat_qual <- ma_e_details %>%
  # Keep only rows where chemical class is PFAS
  filter(chemical_class == "PFAS") %>%
  # Standardize naming of effect size measures
  mutate(ma_es_measure = recode(
    ma_es_measure,
    "? (regression coefficient) value" = "Beta (regression coefficient) value",
    "beta (regression coefficient) value" = "Beta (regression coefficient) value",
    "Adjusted ? (regression coefficient)" = "Beta (regression coefficient) value",
    "adjusted coefficient regression (?)" = "Beta (regression coefficient) value",
    "relative risk" = "Risk ratio",
    "RR (risk ratio)" = "Risk ratio",
    "OR (odds ratio)" = "Odds ratio",
    "fishers z" = "Fisher's Z",
    "log OR (odds ratio)" = "log Odds ratio")) %>% 
  # Standardize naming of chemical identifiers
  mutate(chemical_id = recode(
    chemical_id,
    "n-PFOA" = "PFOA",
    "n-PFOS" = "PFOS",
    "PFHsX" = "PFHxS")) %>% 
  # Merging 'ma_details' and 'ma_e_details' using the common key 'ma_id'
  left_join(ma_details, by = "ma_id", suffix = c("", ".remove")) %>% 
  select(-ends_with(".remove")) %>% 
  filter(status != "excluded")
```

# Effect size conversion

To address the challenge of different effect size metrics reported across the included meta-analyses, I developed a conversion function (*convert_to_logOR()*) to standardize all effect sizes to the log odds ratio (logOR) scale. 

This function systematically converted odds ratios, standardized mean differences, risk ratios (with or without baseline risk adjustment), Fisher’s z values, and logistic regression coefficients to logOR values, based on established methodological approximations (e.g., Borenstein et al., 2021).

```{r, results=FALSE}
# Define a conversion function with an optional baseline risk parameter
convert_to_logOR <- function(effect_measure, point_estimate, ma_l_ci, ma_u_ci, regression_type = NA, baseline_risk = NA) {
  # Ensure the effect measure is treated as character
  effect_measure <- as.character(effect_measure)
  # Ensure point estimate, lower CI, and upper CI are numeric
  point_estimate <- suppressWarnings(as.numeric(as.character(point_estimate)))
  ma_l_ci <- suppressWarnings(as.numeric(as.character(ma_l_ci)))
  ma_u_ci <- suppressWarnings(as.numeric(as.character(ma_u_ci)))
  
  # Conversion for Odds ratio and log Odds ratio
  if (effect_measure == "Odds ratio") {
    # Convert OR to logOR
    return(c(log(point_estimate), log(ma_l_ci), log(ma_u_ci)))
    
  } else if (effect_measure == "log Odds ratio") {
    # Already in logOR
    return(c(point_estimate, ma_l_ci, ma_u_ci))
    
    # Conversion for SMD (standardized mean difference)
  } else if (effect_measure == "SMD (standardized mean difference)") {
    # Following Borenstein et al. (2021): logOR = SMD * pi/sqrt(3)
    logOR_point_estimate <- point_estimate * (pi / sqrt(3))
    
    # Convert lower and upper confidence intervals using the same logic
    logOR_l_ci <- ma_l_ci * (pi / sqrt(3))
    logOR_u_ci <- ma_u_ci * (pi / sqrt(3))
    
    return(c(logOR_point_estimate, logOR_l_ci, logOR_u_ci))
    
    # Conversion for Relative risk / Risk ratio with optional baseline risk
  } else if (effect_measure == "Risk ratio") {
    if (!is.na(baseline_risk)) {
      # Using the conversion: OR = RR * (1-p0) / (1-RR*p0)
      OR <- point_estimate * (1 - baseline_risk) / (1 - point_estimate * baseline_risk)
      OR_l_ci <- ma_l_ci * (1 - baseline_risk) / (1 - ma_l_ci * baseline_risk)
      OR_u_ci <- ma_u_ci * (1 - baseline_risk) / (1 - ma_u_ci * baseline_risk)
      return(c(log(OR), log(OR_l_ci), log(OR_u_ci)))
    } else {
      # If no baseline risk is provided, fallback to the approximation:
      return(c(log(point_estimate), log(ma_l_ci), log(ma_u_ci)))
    }
    
    # Conversion for Fisher's z (often used for correlations)
  } else if (grepl("fishers z", effect_measure, ignore.case = TRUE)) {
    # Convert z to correlation, then to logOR.
    # r = tanh(z)
    # Approximation: logOR = r * pi/sqrt(3)
    r <- tanh(point_estimate)
    return(r * (pi / sqrt(3)))
    
    # Conversion for regression coefficients assumed from logistic regression:
  } else if (effect_measure %in% c("Beta (regression coefficient) value")) {
    # Check if regression_type is 'logistic'
    if (!is.na(regression_type) && regression_type == "logistic") {
      return(c(point_estimate, ma_l_ci, ma_u_ci))
    } else {
      return(rep(NA, 3)) # Not logistic regression, cannot convert
    }
  } else {
    warning("Effect measure conversion not implemented for: ", effect_measure)
    return(rep(NA, 3)) # Return NA for all three
  }
}
```

# Effect size calculation

```{r, results=FALSE, warning=FALSE}
# conversion function to transform effect size metrics into logOR
source(here("function", "conversion.R"))

# Creating a data set for quantitative synthesis (i.e., dat_quant)
# Apply conversion to each row
dat_quant <- dat_qual %>%
  # Apply operations row by row instead of column-wise
  rowwise() %>%
  mutate(
    # Convert various effect size measures to log odds ratios using the custom function
    converted = list(convert_to_logOR(ma_es_measure, ma_point_estimate,
                                     ma_l_ci, ma_u_ci, regression_type, 0.1)),
     # Extract the log odds ratio point estimate from the conversion result
    logOR = converted[1],
    # Extract the lower bound of the log odds ratio confidence interval
    l_ci_logOR = converted[2],
    # Extract the upper bound of the log odds ratio confidence interval
    u_ci_logOR = converted[3]
  ) %>%
  # Return to regular (non-rowwise) tibble structure
  ungroup() %>%
  # Remove the temporary 'converted' list column
  select(-converted) %>% 
  # Keep only rows where the log odds ratio was successfully calculated
  filter(!is.na(logOR))
```

# Removing duplicated meta-analytic estimates

```{r}
dat_quant <- dat_quant %>%
  group_by(chemical_id, health_outcome_group) %>%
  mutate(
    duplicate_set = paste(chemical_id, health_outcome_group, ma_point_estimate, ma_l_ci, ma_u_ci)
  ) %>%
  filter(!duplicated(duplicate_set)) %>%
  select(-duplicate_set) %>%              
  ungroup()
```

Seven meta-analytic estimates were removed because they were duplicates (exact same point estimate, confidence intervals, chemical identity, and health outcome group). Duplicates in meta-analytic estimates occur when two or more meta-analytic estimates are based on exactly the same set of primary studies.

# Testing the impact of our conversion strategy

I assessed whether the original effect size metric (ma_es_measure in the following model) influenced the meta-meta-analysis results by including it as a moderator in a multilevel meta-analytic model (random effects: meta-analysis ID and effect size ID). 

```{r, include=FALSE, warning=FALSE}
dat_quant$ma_es_measure <- as.factor(dat_quant$ma_es_measure)
dat_quant$ma_es_measure <- relevel(dat_quant$ma_es_measure, ref = "Odds ratio")

dat_quant <- dat_quant %>%
  mutate(ma_es_measure = recode(
    ma_es_measure,
    "Beta (regression coefficient) value" = "Beta",
    "SMD (standardized mean difference)" = "SMD")) %>% 
  mutate(se = ((u_ci_logOR - l_ci_logOR)/(2*1.96)))  # Convert 95% CI to standard error (se)
```

```{r, results=FALSE, warning=FALSE}
dat_quant <- dat_quant %>% 
  mutate(pair = paste0(health_outcome_group, chemical_id)) # The new variable 'pair' will be used as cluster in the impute_covariance_matrix() function, effectively creating a variance-covariance matrix.

# Create the VCV matrix assuming rho = 0.5 for within-pair correlation
VCV_test <- impute_covariance_matrix(vi = dat_quant$se^2,  
                                cluster = dat_quant$pair,
                                r = 0.5)

mod_test <- rma.mv(yi = logOR,  
              V = VCV_test, 
              random = list(~1|ma_id, 
                            ~1|ma_e_id), 
              mods = ~ ma_es_measure - 1,
              data = dat_quant)
```

```{r, include=FALSE, warning=FALSE}
# Display model results
summary(mod_test)
```

```{r, echo=FALSE, warning=FALSE}
orchard_plot(
  object = mod_test,
  mod = "ma_es_measure",
  group = "ma_id",
  xlab = "log Odds Ratio",
  colour  = FALSE,
  transfm = "none",
  trunk.size = 0.8,
  branch.size = 1.8) + 
  theme(
    panel.border = element_rect(colour = "black", fill = NA, size = 1.3),
    axis.text.x = element_text(size = 10)
  )
```

The moderator analysis revealed a statistically significant impact of the effect size metric on the overall estimates (p = 0.0003). 

To reduce potential bias and improve consistency, I subsequently restricted the dataset to only those effect sizes that were originally reported on the odds ratio (OR) or log odds ratio (logOR) scale (number of effect sizes: 206, number of meta-analyses: 23).

# First Research Question

**Question:** How does exposure to per- and polyfluoroalkyl substances (PFAS) affect human health?

**Objective:** To evaluate the magnitude and variability of associations between PFAS exposure and adverse human health outcomes based on multiple meta-analyses.

## The Overall Result

Our meta-meta-analytic approach addressed heterogeneity at two levels. First, we modeled between-meta-analysis heterogeneity in reported effect sizes (logOR) using a multilevel meta-analytic model. This allowed us to partition the variance in outcomes across and within meta-analyses. Second, we meta-analyzed heterogeneity as the outcome by synthesizing the I² values reported by the included meta-analyses. These were transformed into ln(H) to quantify and model differences in the internal heterogeneity of primary studies.

Random effect structure:

- **~1 | ma_id** introduces a random intercept for each meta-analysis. It acknowledges that different meta-analyses may have different baseline effects due to design, populations, etc.

- **~1 | ma_e_id** introduces a random intercept for each effect size estimate within a meta-analysis. It accounts for non-independence of estimates within the same meta-analysis.

```{r, results=FALSE}
dat_quant <- dat_quant %>% 
  filter(ma_es_measure %in% c("Odds ratio", "log Odds ratio"))

VCV <- impute_covariance_matrix(vi = dat_quant$se^2,  
                                cluster = dat_quant$pair,
                                r = 0.5)

mod_overall <- rma.mv(yi = logOR,  
                        V = VCV, 
                        random = list(~1|ma_id, 
                                      ~1|ma_e_id), 
                        data = dat_quant,
                        test = "t")
```


```{r, echo=FALSE}
#mod_overall <- robust(mod_overall, dat_quant$pair) #The robust() function computes robust standard errors that account for non-normality and/or heteroscedasticity in the residuals.
summary(mod_overall)
```

```{r, include=FALSE}
#Extracting data from the model
overall_results <- tibble(
  lnOR = as.numeric(mod_overall$b),
  lnOR_ci_lower = mod_overall$ci.lb,
  lnOR_ci_upper = mod_overall$ci.ub,
  lnOR_p_value = mod_overall$pval
)
```

```{r, results=FALSE}
# 1. Calculate H², lnH², and SElnH
dat_H2 <- dat_quant %>%
  mutate(n_ps_e = if_else(is.na(n_ps_e), n_ps, n_ps_e)) %>% #For each row, checks if n_ps_e (i.e., number of primary study estimates) is NA. If it is, replaces it with the value from n_ps (number of primary studies).
  filter(n_ps_e > 2) %>%  # Explicitly exclude cases where SElnH would be invalid
  mutate(
    I_squared = as.numeric(I_squared),
    # Calculate H² from I²
    H2 = 1 / (1 - (I_squared / 100)),
    lnH = log(sqrt(H2)),
    
    # Calculate SElnH
    k = n_ps_e, # number of effect sizes (primary study estimates)
    SElnH = sqrt((1 / (2 * (k - 2))) * (1 - (1 / (3 * (k - 2))^2))),

    # Calculate Confidence Intervals for lnH
    lnH_ci_lower = lnH - 1.96 * SElnH,
    lnH_ci_upper = lnH + 1.96 * SElnH
  ) %>% 
  filter(!is.infinite(lnH)) %>% # removing lnH = Inf (it happens when I-squared = 0)
  group_by(chemical_id) %>%
  filter(n_distinct(ma_e_id) > 1) %>% # at least 2 meta-analytic estimates
  ungroup() %>% 
  mutate(chemical_id = droplevels(factor(chemical_id)))

# Create the VCV matrix assuming rho = 0.5 for within-pair correlation
VCV_H2 <- impute_covariance_matrix(vi = dat_H2$se^2,  
                                   cluster = dat_H2$pair,
                                   r = 0.5)
```


```{r, warning=FALSE}
mod_overall_H2 <- rma.mv(
  yi = lnH, 
  V = VCV_H2, 
  random = list(~1|ma_id,
                ~1|ma_e_id), 
  data = dat_H2,
  test = "t"
)

summary(mod_overall_H2)
```

```{r, include=FALSE}
#Extracting data from the model
overall_results_H2 <- tibble(
  lnH = as.numeric(mod_overall$b),
  lnH_ci_lower = mod_overall$ci.lb,
  lnH_ci_upper = mod_overall$ci.ub,
  lnH_p_value = mod_overall$pval
) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * lnH_ci_lower),
    H2_ub     = exp(2 * lnH_ci_upper),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

I2_text <- paste0("I² = ", round(overall_results_H2$I2, 1), 
                  "% [", round(overall_results_H2$I2_ci_lower, 1), 
                  "–", round(overall_results_H2$I2_ci_upper, 1), "%]")
```


```{r, echo=FALSE}
overall_plot <- orchard_plot(
  object = mod_overall,
  group = "ma_id",
  xlab = "logOR",
  transfm = "none",
  trunk.size = 0.8,
  branch.size = 2.5,
  alpha = 1
) + 
  # Add faded red background for x < 0
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0, 
           fill = "green", alpha = 0.08) + 
  # Add faded green background for x > 0
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 0, ymax = Inf, 
           fill = "red", alpha = 0.08) + 
  annotate("text", 
           x = Inf, y = Inf, 
           label = I2_text, 
           hjust = 1.1, vjust = 1.5, 
           size = 4.5, fontface = "italic")  +
  theme(
    legend.position.inside = c(0.05, 0.05),  # x, y coordinates relative to the plot (0 = left/bottom, 1 = right/top)
    legend.justification = c(0, 0),   # anchor the legend by its bottom-left corner
    legend.background = element_rect(fill = alpha("green", 0.001), color = NA),
    legend.key = element_rect(fill = "transparent")  # make individual legend keys blend in
  )

print(overall_plot)
```

*Overall association between PFAS exposure and adverse health outcomes, expressed as a log Odds Ratio (logOR). Positive values indicate increased odds of adverse outcomes with higher PFAS exposure. This estimate is based on a meta-meta-analysis of 207 meta-analytic effect sizes (k) drawn from 23 published meta-analyses. The pooled effect size is shown as a black circle, with thicker horizontal bars indicating its 95% confidence interval and thinner bars representing the 95% prediction interval. Light-blue bubbles depict individual effect sizes, scaled by their precision (inverse of the standard error; see legend). The number in parentheses denotes the number of studies contributing to the overall effect. A negative association is shown in the green-shaded area (logOR < 0), while a positive association appears in the red-shaded area (logOR > 0).*

```{r, include=FALSE}
# I²
i2_results_no_transf <- i2_ml(mod_overall)
print(i2_results_no_transf)
# Print I² values
cat("Heterogeneity (I\u00b2 between studies):", round(i2_results_no_transf["I2_ma_id"], 1), "%\n")
cat("Heterogeneity (I\u00b2 within studies):", round(i2_results_no_transf["I2_ma_e_id"], 1), "%\n")
```

```{r, include=FALSE}
merged_overall_results <- bind_cols(overall_results, overall_results_H2)

ggplot(merged_overall_results, aes(x = lnOR, y = I2)) +
  # Horizontal error bars (for lnOR)
  geom_errorbarh(aes(xmin = lnOR_ci_lower, xmax = lnOR_ci_upper), height = 2, alpha = 0.5) +
  # Vertical error bars (for I2)
  geom_errorbar(aes(ymin = I2_ci_lower, ymax = I2_ci_upper), width = 0.01, alpha = 0.5) +
  # Point
  geom_point(size = 5) +
  # Reference lines
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  # Axes
  scale_x_continuous(limits = c(-0.1, 0.1), breaks = seq(-0.1, 0.1, by = 0.1)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  # Labels
  labs(
    x = "Effect size (logOR)",
    y = "Heterogeneity (I\u00b2 %)"
  ) +
  theme_minimal(base_size = 13)
```

## Summary Results RQ1

**1)**  Across all meta-analyses included in our synthesis, exposure to PFAS was associated with a statistically significant increase in the odds of experiencing adverse health outcomes. On average, PFAS exposure was linked to a 5.8% increase in risk (95% CI: 3.1%–8.6%), suggesting a modest but measurable impact on human health.

**2)**  The consistency of findings varied depending on the level of analysis. While individual meta-analyses generally reported low within-review heterogeneity (mean I² ≈ 15%), our overall model revealed high heterogeneity (I² = 87%) across all meta-analyses. Most of this heterogeneity arose within, rather than between, meta-analyses. This discrepancy highlights that although individual reviews often appear internally consistent, notable variability exists when their results are aggregated. Such inconsistency likely reflects differences in study populations, PFAS exposure measurements, and methodological quality across reviews.

# Second Research Question

## Chemicals

**Question:** What individual PFAS are significantly associated with adverse health outcomes?

To evaluate chemical-specific associations, I conducted separate multilevel meta-analyses for each chemical. First, I identified all unique chemicals in the dataset and then, for each chemical, filtered the data accordingly. I run the model when at least two meta-analytic estimates contributed data for a given chemical. Using a multilevel meta-analytic model (random effects: meta-analysis ID and effect size ID), I estimated the pooled log odds ratio (logOR), its confidence interval, and p-value. Results were stored in a unified table. If a model failed to converge or insufficient data were available, missing values (NA) were recorded instead. This approach allowed a standardized and robust summary of the strength and variability of associations for each individual chemical.

```{r, results=FALSE, warning=FALSE}
# Get a list of chemicals
chemicals <- unique(dat_quant$chemical_id)

# Run separate meta-analyses for each chemical_id
results_list <- map_dfr(chemicals, function(chem) {
  dat_sub <- dat_quant %>% filter(chemical_id == chem)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) {  # Require at least 2 meta-analytic estimates
    tryCatch({
      # Calculate VCV matrix for this subset
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = logOR,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        chemical_id = chem,
        logOR = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(chemical_id = chem, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
     tibble(chemical_id = chem, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
           #tau2 = NA, I2 = NA, CV = NA,
           k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE, warning=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
plot_data_chemical <- results_list %>% 
  filter(!is.na(logOR)) %>% 
  arrange(logOR)

forest_plot_chemical <- ggplot(plot_data_chemical, aes(y = reorder(chemical_id, logOR), x = logOR)) +
  geom_point(aes(size = k), 
             color = ifelse(plot_data_chemical$pval > 0.05, "grey", "black"),
             alpha = 1) +
  scale_size(range = c(5, 13)) +
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub),
                 height = 0.2,
                 alpha = ifelse(plot_data_chemical$pval > 0.05, 0.6, 1)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = min(ci.lb, na.rm = TRUE) - 0.2),
            hjust = 0, size = 5,
            fontface = ifelse(plot_data_chemical$pval < 0.05, "bold", "plain")) +
  xlab("logOR") +
  ylab("PFAS") +
  theme_minimal() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
        axis.text.x = element_text(size = 15))

forest_plot_chemical
```

```{r, results=FALSE, warning=FALSE}
# Run separate meta-analyses for each chemical_id
results_list2 <- map_dfr(chemicals, function(chem) {
  dat_sub <- dat_H2 %>% filter(chemical_id == chem)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) {  # Require at least 2 meta-analytic estimates
    tryCatch({
      # Calculate VCV matrix for this subset
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = lnH,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        chemical_id = chem,
        lnH = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(chemical_id = chem, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
     tibble(chemical_id = chem, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
           #tau2 = NA, I2 = NA, CV = NA,
           k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE}
custom_order <- c("PFDoDA", "PFUnDA", "PFHpA", "PFDA", "PFAS", "PFNA", "PFOS", "PFHxS", "PFOA")

plot_data_chemical_H2 <- results_list2 %>% 
  filter(!is.na(lnH)) %>% 
  mutate(chemical_id = factor(chemical_id, levels = custom_order)) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * ci.lb),
    H2_ub     = exp(2 * ci.ub),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

plot_data_chemical_merged <- left_join(plot_data_chemical, plot_data_chemical_H2 %>% 
                                         select(chemical_id, I2, I2_ci_lower, I2_ci_upper), 
                                       by = "chemical_id")
```


```{r, include=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
forest_plot_chemical <- forest_plot_chemical +
  geom_text(data = plot_data_chemical_merged,
            aes(label = paste0(
              "I² = ", round(I2, 1), "% [", 
              round(I2_ci_lower, 1), "–", 
              round(I2_ci_upper, 1), "]")),
            hjust = -0.2, vjust = -0.7, size = 4.5)


forest_plot_chemical
```

```{r, echo=FALSE}
ggplot(plot_data_chemical_merged, aes(x = logOR, y = I2, label = chemical_id, size = k, color = pval < 0.05 | pval < 0.05)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(size = 4, max.overlaps = Inf, box.padding = 1, min.segment.length = 0) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  
  # Quadrant text
  annotate("text", x = -0.095, y = 95, label = "harmless\nlow consistency", hjust = 0, size = 4) +
  annotate("text", x = 0.06, y = 95, label = "harmful\nlow consistency", hjust = 0, size = 4) +
  annotate("text", x = 0.06, y = 3, label = "harmful\nhigh consistency", hjust = 0, size = 4) +
  annotate("text", x = -0.095, y = 3, label = "harmless\nhigh consistency", hjust = 0, size = 4) +

  scale_color_manual(values = c("grey50", "firebrick"), labels = c("No", "Yes")) +
  scale_size(range = c(3, 12)) +
  scale_x_continuous(limits = c(-0.1, 0.1), breaks = seq(-0.1, 0.1, by = 0.05)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  labs(
    x = "Effect size (logOR)",
    y = "Heterogeneity (I\u00b2 %)",
    color = "logOR p < 0.05:",
    size = "k:"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.margin = margin(),
    panel.grid = element_blank()
  ) +
  guides(
    color = "none",
    size = guide_legend(
    override.aes = list(color = "grey50"),
    order = 2
  )
  )

```

*Each estimate is based on a separate meta-analysis for each PFAS chemical.*

## Health Outcome Group

The meta-analyses included in our study pooled data from studies on various types of adverse health outcomes. We grouped these health types into groups: the higher grouping level according to the ICD-11 for Mortality and Morbidity Statistics.

**Question:** What groups of adverse health outcome are significantly associated with PFAS exposure?

Similarly to the previous code, I ran separate multilevel meta-analyses for each health outcome group to assess associations by health outcome. For each group, I filtered the dataset and fitted a random-effects model (with random intercepts for meta-analysis ID and effect size ID) when at least two meta-analytic estimates contributed data. For each health outcome, I estimated the pooled log odds ratio (logOR), its confidence interval, and p-value, recording NA values if model fitting was not possible.

```{r, include=FALSE}
dat_quant$health_outcome_group <- as.factor(dat_quant$health_outcome_group)

dat_quant <- dat_quant %>% 
mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  ))
```

```{r, results=FALSE, warning=FALSE}
# Get a list of outcome groups
outcomes <- unique(dat_quant$health_outcome_group)

# Loop over each health outcome group
results_health <- map_dfr(outcomes, function(outcome) {
  dat_sub <- dat_quant %>% filter(health_outcome_group == outcome)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) { # requires at least 2 meta-analytic estimates
    tryCatch({
      
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = logOR,  
                      V = se^2,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        health_outcome_group = outcome,
        logOR = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(health_outcome_group = outcome, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
    tibble(health_outcome_group = outcome, logOR = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```


```{r, include=FALSE, warning=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
plot_data_health <- results_health %>% 
  filter(!is.na(logOR)) %>% 
  arrange(logOR) %>% 
  filter(n > 1)

forest_plot_health <- ggplot(plot_data_health, aes(y = reorder(health_outcome_group, logOR), x = logOR)) +
  geom_point(aes(size = k), 
             color = ifelse(plot_data_health$pval > 0.05, "grey", "black"),
             alpha = 1) +
  scale_size(range = c(5, 13)) +
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub),
                 height = 0.2,
                 alpha = ifelse(plot_data_health$pval > 0.05, 0.6, 1)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = min(ci.lb, na.rm = TRUE) - 0.2),
            hjust = 0, size = 5,
            fontface = ifelse(plot_data_health$pval < 0.05, "bold", "plain")) +
  xlab("logOR") +
  ylab("Health Outcome Group") +
  theme_minimal() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
        plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
        axis.text.x = element_text(size = 15))

forest_plot_health
```


```{r, results=FALSE, warning=FALSE}
dat_H2 <- dat_H2 %>% 
mutate(health_outcome_group = recode(
    health_outcome_group,
    "Endocrine, nutritional or metabolic diseases" = "Endocrine diseases",
    "Diseases of the circulatory system" = "Diseases of the\ncirculatory system",
    "Pregnancy, childbirth or the puerperium" = "Pregnancy or\nchildbirth",
    "Certain conditions originating in the perinatal period" = "Perinatal period",
    "Mental, behavioural or neurodevelopmental disorders" = "Neurodevelopmental\ndisorders",
    "Diseases of the musculoskeletal system or connective tissue" = "Diseases of the\nmusculoskeletal system",
    "Symptoms, signs or clinical findings, not elsewhere classified" = "Symptoms not\nelsewhere classified",
    "Diseases of the respiratory system" = "Diseases of the\nrespiratory system",
    "Diseases of the genitourinary system" = "Diseases of the\ngenitourinary system"
  ))

# Get a list of outcome groups
outcomes <- unique(dat_H2$health_outcome_group)

# Loop over each health outcome group
results_health_H2 <- map_dfr(outcomes, function(outcome) {
  dat_sub <- dat_H2 %>% filter(health_outcome_group == outcome)
  
  if (n_distinct(dat_sub$ma_e_id) > 1) { # requires at least 2 meta-analytic estimates
    tryCatch({
      
      VCV_sub <- impute_covariance_matrix(vi = dat_sub$se^2,
                                          cluster = dat_sub$pair,
                                          r = 0.5)
      
      model <- rma.mv(yi = lnH,  
                      V = VCV_sub,
                      random = list(~1|ma_id,
                                    ~1|ma_e_id),
                      test = "t", 
                      sparse = TRUE,
                      data = dat_sub,
                      control = list(iter.max = 1000, rel.tol = 1e-8))
      
      # Calculate heterogeneity statistics
      # tau2_raw <- sum(model$sigma2)
      # sigma2_v <- sum(1 / model$vi) * (model$k - 1) / (sum(1 / model$vi)^2 - sum((1 / model$vi)^2))
      # I2_raw <- 100 * (tau2_raw / (tau2_raw + sigma2_v))
      # CV_raw <- sqrt(tau2_raw) / abs(model$b[1,1])
      
      tibble(
        health_outcome_group = outcome,
        lnH = model$b[1,1],
        ci.lb = model$ci.lb,
        ci.ub = model$ci.ub,
        pval = model$pval,
        # tau2 = tau2_raw,
        # I2 = I2_raw,
        # CV = CV_raw,
        k = nrow(dat_sub),
        n = n_distinct(dat_sub$ma_id)
      )
    }, error = function(e) {
      tibble(health_outcome_group = outcome, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
    })
  } else {
    tibble(health_outcome_group = outcome, lnH = NA, ci.lb = NA, ci.ub = NA, pval = NA,
             #tau2 = NA, I2 = NA, CV = NA,
             k = nrow(dat_sub), n = n_distinct(dat_sub$ma_id))
  }
})
```

```{r, include=FALSE}
custom_order <- c("Neurodevelopmental\ndisorders", "Neoplasms", "Perinatal period", "Pregnancy or\nchildbirth", "Diseases of the\ncirculatory system", "Endocrine diseases")

plot_data_health_H2 <- results_health_H2 %>% 
  filter(!is.na(lnH)) %>% 
  mutate(health_outcome_group = factor(health_outcome_group, levels = custom_order)) %>% 
  mutate(
    # 1) Compute H2 and its CIs
    H2        = exp(2 * lnH),
    H2_lb     = exp(2 * ci.lb),
    H2_ub     = exp(2 * ci.ub),

    # 2) Convert to I2 and truncate to [0,100]
    I2           = pmin(100, pmax(0, (H2 - 1)/H2  * 100)),
    I2_ci_lower  = pmin(100, pmax(0, (H2_lb - 1)/H2_lb * 100)),
    I2_ci_upper  = pmin(100, pmax(0, (H2_ub - 1)/H2_ub * 100))
  )

plot_data_health_merged <- left_join(plot_data_health, plot_data_health_H2 %>% 
                                         select(health_outcome_group, I2, I2_ci_lower, I2_ci_upper), 
                                       by = "health_outcome_group")
```


```{r, include=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
forest_plot_health2 <- forest_plot_health +
  geom_text(data = plot_data_health_merged,
            aes(label = paste0(
              "I² = ", round(I2, 1), "% [", 
              round(I2_ci_lower, 1), "–", 
              round(I2_ci_upper, 1), "]")),
            hjust = -0.2, vjust = -0.7, size = 4.5)


forest_plot_health2
```

```{r, echo=FALSE}
ggplot(plot_data_health_merged, aes(x = logOR, y = I2, label = health_outcome_group, size = k, color = pval < 0.05 | pval < 0.05)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(size = 4, max.overlaps = Inf, box.padding = 1, min.segment.length = 0) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "grey40") +
  
  # Quadrant text
  annotate("text", x = -0.095, y = 95, label = "harmless\nlow consistency", hjust = 0, size = 4) +
  annotate("text", x = 0.06, y = 95, label = "harmful\nlow consistency", hjust = 0, size = 4) +
  annotate("text", x = 0.06, y = 3, label = "harmful\nhigh consistency", hjust = 0, size = 4) +
  annotate("text", x = -0.095, y = 3, label = "harmless\nhigh consistency", hjust = 0, size = 4) +

  scale_color_manual(values = c("grey50", "firebrick"), labels = c("No", "Yes")) +
  scale_size(range = c(3, 12)) +
  scale_x_continuous(limits = c(-0.1, 0.1), breaks = seq(-0.1, 0.1, by = 0.05)) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 25)) +
  labs(
    x = "Effect size (logOR)",
    y = "Heterogeneity (I\u00b2 %)",
    color = "logOR p < 0.05:",
    size = "k:"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.margin = margin(),
    panel.grid = element_blank()
  ) +
  guides(
    color = "none",
    size = guide_legend(
    override.aes = list(color = "grey50"),
    order = 2
  )
  )
```


## Summary Results

**1)**  

-  **PFOS** and **PFOA** both show statistically significant positive associations (logOR = 0.061 and 0.073, respectively), meaning exposure is associated with increased odds of adverse outcomes. However, both also have moderate-to-high I² values (around 63–69%), suggesting that although the associations are consistent enough to reach statistical significance, there is notable heterogeneity in the size of the effect across meta-analyses.

-  **PFHxS** and **PFNA** have positive but non-significant logORs and similarly high I² values (~62%), implying inconsistent evidence. The direction is generally toward harm, but effect sizes vary too much across studies to confirm a reliable association.

-  **PFUnDA** and **PFDA** have very low I² values (~14%) and small, non-significant logORs, suggesting high consistency, but no compelling evidence of a harmful effect. This could imply a genuine lack of association or uniformly small effects across studies.

-  **PFDoDA** and **PFHpA** show near-zero or slightly negative logORs and moderate I² values (~35–46%), indicating modest inconsistency, but again no meaningful association with health outcomes.

-  The **PFAS** (unspecified mix) group shows a near-zero, non-significant logOR and very high heterogeneity (I² = 69.8%), implying that the mixed results likely reflect true variability across the included studies rather than random error.

**2)**  

-  **Diseases of the circulatory system**: Strongest and most consistent association: PFAS exposure is associated with a statistically significant increase in odds (logOR = 0.084). While heterogeneity is moderate-to-high (I² = 67.2%), the tight confidence interval and high precision suggest a fairly robust relationship despite study-level differences.

-  **Pregnancy, childbirth or the puerperium**: A significant but smaller effect (logOR = 0.049) with low heterogeneity (I² = 19.4%). This implies a consistent and reliable association, suggesting that even small effects are replicable across studies.

-  **Perinatal period**: A positive but non-significant effect (logOR = 0.041) with low-to-moderate heterogeneity (I² = 32.1%). Results are fairly consistent, but the effect may be small or diluted by study design variation.

-  **Endocrine diseases**: A relatively large but non-significant effect (logOR = 0.101) paired with moderate heterogeneity (I² = 54.4%). This combination implies uncertainty and variation across studies — some may show strong effects, others null or opposite. More research is likely needed.

-  **Neoplasms**: Shows low, non-significant effect (logOR = 0.028) but very high heterogeneity (I² = 92.2%). This suggests results are highly inconsistent, and the small average effect likely masks large between-study variation, possibly due to differences in cancer types, latency periods, or exposure metrics.

-  **Neurodevelopmental disorders**: No evidence of association (logOR ~ 0) with moderate heterogeneity (I² = 50.5%), suggesting that effects vary somewhat across studies, but overall there's no clear or consistent signal of harm.

# Third Research Question

**Question:** What are the significant associations between individual PFAS and specific health outcomes, and how strong are these correlations?

**Objective:** To determine significant PFAS-health outcome correlations and assess the strength of these relationships.

BUT,

Before addressing our third research question through quantitative analysis, we first perform a qualitative assessment to determine the number of meta-analyses and effect sizes available for each combination of individual PFAS and health outcome group.

## Qualitative Synthesis

### Overview of the evidence

The following two graphs show the number of meta-analyses for each combination of PFAS-health outcome group (first graph) and the number of effect sizes for the same combinations (second graph).

These two graphs are useful for visualizing the evidence base across PFAS–health outcome combinations. The first graph helps identify which health outcomes have been more frequently addressed at the meta-analysis level, while the second graph shows the volume of individual effect sizes contributing to each combination. Together, they highlight areas with strong meta-analytic support and reveal gaps in the literature where data may be sparse or underexplored.

We use the personalized function *custom_meta_aggregate()* to perform a meta-analysis and to build the data frame used for plotting the graphs. The results of the meta-analysis will be showed in the following section "Quantitative synthesis". 

```{r, out.height=600, out.width=1000, fig.width=11, fig.height=10}
# custom function
source(here("function", "custom.R"))

# get estimate for each cell
est_dat <- dat_quant %>% group_by(chemical_id, health_outcome_group) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=10}
# traditional map with the number of study
est_dat$chemical_id <- as.factor(est_dat$chemical_id)

Box1_map1 <- ggplot(est_dat, aes(x = chemical_id, y = health_outcome_group, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Group") +
  scale_size(range = c(8,20)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of studies") + 
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title = element_text(size = 12, face = "bold")) 

Box1_map1

```

```{r,echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=10}
# traditional map with the number of effect size
Box1_map2 <- ggplot(est_dat, aes(x = chemical_id, y = health_outcome_group, size = n_es)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) + 
  labs(x = "PFAS", y = "Health Outcome Group") +
  scale_size(range=c(8,20)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal',  
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_es)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of effect sizes") +
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 12),
         axis.title = element_text(face = "bold", size = 12))

Box1_map2
```

Five groups out of eleven did not have more than one meta-analytic estimate for any chemical compound.

Now, we focus on the 6 groups that have at least 2 meta-analyses for any PFAS chemical. We look at the specific health outcome type investigated in the meta-analyses.

### Focus on health outcomes groups from at least 2 meta-analyses

Health outcome groups:

-  A = Diseases related to pregnancy or childbirth
-  B = Neoplasms
-  C = Neurodevelopmental disorders
-  D = Endocrine diseases
-  E = Diseases of the circulatory system
-  F = Diseases related to the perinatal period

```{r, include=FALSE}
est_dat2 <- dat_quant %>% 
  filter(health_outcome_group == "Pregnancy or\nchildbirth")

est_dat2 <- est_dat2 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map1 <- ggplot(est_dat2, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme( axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_text(size = 12, face = "bold")) 

Box2_map1
```

```{r, include=FALSE}
est_dat3 <- dat_quant %>% 
  filter(health_outcome_group == "Neoplasms")

est_dat3 <- est_dat3 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map2 <- ggplot(est_dat3, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_blank()) 

Box2_map2
```

```{r, include=FALSE}
est_dat4 <- dat_quant %>% 
  filter(health_outcome_group == "Neurodevelopmental\ndisorders")

est_dat4 <- est_dat4 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map3 <- ggplot(est_dat4, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_text(size = 12, face = "bold")) 

Box2_map3
```

```{r, include=FALSE}
est_dat5 <- dat_quant %>% 
  filter(health_outcome_group == "Endocrine diseases")

est_dat5 <- est_dat5 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map4 <- ggplot(est_dat5, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_blank(),
         axis.title.y = element_blank()) 

Box2_map4
```

```{r, include=FALSE}
est_dat6 <- dat_quant %>% 
  filter(health_outcome_group == "Diseases of the\ncirculatory system")

est_dat6 <- est_dat6 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map5 <- ggplot(est_dat6, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title = element_text(size = 12, face = "bold")) 

Box2_map5
```

```{r, include=FALSE}
est_dat7 <- dat_quant %>% 
  filter(health_outcome_group == "Perinatal period")

est_dat7 <- est_dat7 %>% group_by(chemical_id, health_outcome_type) %>%
  group_modify(~ custom_meta_aggregate(.x, rho = 0.5)) %>% ungroup()
```

```{r,include=FALSE}
Box2_map6 <- ggplot(est_dat7, aes(x = chemical_id, y = health_outcome_type, size = n_studies) ) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) + 
  labs(x = "PFAS", y = "Health Outcome Type") +
  scale_size(range=c(8,15)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + # 
  scale_y_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position='top', 
        legend.justification='right',
        legend.direction='horizontal', 
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black")) +
  geom_text(aes(label = as.character(n_studies)), size = 4, color = "gray10") +
  labs(caption = "The value in the cell is the number of studies") + 
   theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
         axis.text.x = element_text(angle = 45, hjust = 1),
         axis.text = element_text(size = 11),
         axis.title.x = element_text(size = 12, face = "bold"),
         axis.title.y = element_blank()) 

Box2_map6
```


```{r, echo=FALSE, out.height=1000, out.width=1000, fig.width=11, fig.height=12}
plot_grid(Box2_map1, Box2_map2, Box2_map3, Box2_map4, Box2_map5, Box2_map6, 
          labels = c('A','B','C','D','E','F'),
          label_size = 14,
          nrow = 3,
          ncol = 2)
```

## Quantitative Synthesis

Now that I have a clear understanding of the available evidence, I can plot the results of the subgroup analyses. I splitted the dataset by two grouping variables: chemical_id and health_outcome_group. For each combination of these two groups, I'm running the meta-analysis (using the *custom_meta_aggregate()* function). This allows me to obtain separate effect size estimates for each chemical-health outcome subgroup.

```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=10, fig.height=7}
est_dat <- est_dat %>%
  filter(n_studies > 1)

# Plot
ggplot(est_dat, aes(x = chemical_id, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
  geom_point(aes(color = pval < 0.05), size = 2.5) +
  geom_errorbar(aes(color = pval < 0.05), width = 0.2) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "black"), guide = "none") +
  facet_wrap(~ health_outcome_group, scales = "free_y") +
  labs(title = "Estimated Interaction Effects",
       x = "PFAS",
       y = "Log Odds Ratio (logOR)") +
  theme_minimal(base_size = 12) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(
    plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "none"
  )
```

## Summary Results RQ3

**1)**  The following combinations of PFAS-health outcomes showed significant associations: 

-  PFNA - Diseases related to the perinatal period:
   estimate = 0.123, CI = [ 0.017, 0.228], p-val = 0.0406, n = 3, k = 4.
-  PFHxS - Diseases of the circulatory system:
   estimate = 0.032, CI = [0.016, 0.048], p-val = 0.0189, n = 3, k = 5.
-  PFNA - Diseases of the circulatory system:
   estimate = 0.093, CI = [0.009, 0.177], p-val = 0.0421, n = 3, k = 5.
-  PFOA - Diseases of the circulatory system:
   estimate = 0.131, CI = [0.075, 0.186], p-val = 0.0134, n = 3, k = 5.
-  PFOS - Diseases of the circulatory system:
   estimate = 0.172, CI = [0.038, 0.305], p-val = 0.0333, n = 3, k = 5.
-  PFUnDA - Diseases related to pregnancy or childbirth:
   estimate = -0.136, CI = [-0.229, -0.043], p-val = 0.0263, n = 3, k = 4.


# Sensitivity Analysis

## Metaregressions

Here we run a classic uni-moderator meta-regression analysis to test the robustness of our subgroup analysis:

```{r, include=FALSE}
dat_quant$chemical_id <- as.factor(dat_quant$chemical_id)
```

```{r, results=FALSE}
mod2 <- rma.mv(yi = logOR,
               V = VCV,
               mods = ~ chemical_id -1,
               random = list(~1|ma_id,
                             ~1|ma_e_id),
               test = "t",
               sparse = T,
               data = dat_quant,
               control = list(iter.max = 1000,
                              rel.tol = 1e-8))

summary(mod2)
```

```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
r2_mod2 <- r2_ml(mod2, dat_quant)

k_n_data <- dat_quant %>% 
  group_by(chemical_id) %>%
  arrange(chemical_id) %>% 
  summarise(k = n(), n = length(unique(ma_id)))

res_tab1 <- broom::tidy(mod2)
res_tab1$ci.lb <- mod2$ci.lb
res_tab1$ci.ub <- mod2$ci.ub
res_tab1$pval <-mod2$pval
res_tab1 <- res_tab1 %>% 
  mutate(
    chemical_id = str_remove(term, "^chemical_id"),  # Remove 'Pchemical_id: ' prefix
  ) %>% 
  arrange(chemical_id)

res_tab1 <- res_tab1 %>% 
  mutate(k = k_n_data$k) %>% 
  mutate(n = k_n_data$n)

# Prepare the data for plotting and order chemical_id by estimate value
plot_data1 <- res_tab1 %>%
  as.data.frame() %>% 
  filter(n > 1) %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot1 <- ggplot(plot_data1, aes(y = reorder(chemical_id, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data1$pval > 0.05, "grey", "black"), 
             alpha = 1) +  # Add transparency for better visibility
  scale_size(range = c(5, 13)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data1$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = - 0.3),
            hjust = 0, size = 5, # Add k values as text next to the points
            fontface = ifelse(plot_data1$pval < 0.05, "bold", "plain")) + 
  xlab("logOR") +
  ylab("PFAS") +
  #ggtitle("B") +
  theme_minimal() +  # Use a minimal theme
  annotate(geom = "text",
           x = -0.15,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_mod2[1],4)),
           color ="black",
           parse = TRUE, 
           size = 5) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
         plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 15),
       axis.text.x = element_text(size = 15)) # +
   # scale_x_break(c(4, 6)) +
   # scale_x_continuous(breaks = seq(0, 4, by = 1), limits = c(-0.21, 4))

forest_plot1
```

- Now we do the same but using health outcome group as moderator.

```{r, results=FALSE}
mod4 <- rma.mv(yi = logOR,  
                  V = VCV,
                  mods = ~ health_outcome_group -1,
                   random = list(~1|ma_id,
                                 ~1|ma_e_id),
                   test = "t",
                   sparse = T,
                   data = dat_quant,
                   control = list(iter.max = 1000, 
                                  rel.tol = 1e-8))

summary(mod4)
```

```{r, echo=FALSE, out.height=600, out.width=1000, fig.width=11, fig.height=8}
r2_mod4 <- r2_ml(mod4, dat_quant)

k_n_data3 <- dat_quant %>% 
  group_by(health_outcome_group) %>%
  arrange(health_outcome_group) %>% 
  summarise(k = n(), n = length(unique(ma_id)))

res_tab3 <- broom::tidy(mod4)
res_tab3$ci.lb <- mod4$ci.lb
res_tab3$ci.ub <- mod4$ci.ub
res_tab3$pval <- mod4$pval
res_tab3 <- res_tab3 %>% 
  mutate(
    health_outcome_group = str_remove(term, "^health_outcome_group"),  # Remove 'Pchemical_id: ' prefix
  ) %>% 
  arrange(health_outcome_group)

res_tab3 <- res_tab3 %>% 
  mutate(k = k_n_data3$k) %>% 
  mutate(n = k_n_data3$n)

# Prepare the data for plotting and order health_outcome_group by estimate value
plot_data3 <- res_tab3 %>%
  as.data.frame() %>% 
  #filter(k > 1) %>% 
  filter(n > 1) %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot3 <- ggplot(plot_data3, aes(y = reorder(health_outcome_group, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data3$pval > 0.05, "grey", "black"),
             alpha = 1) +  # Add transparency for better visibility 
  scale_size(range = c(5, 13)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data3$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = - 0.3),
            hjust = 0, size = 5, # Add k values as text next to the points
            fontface = ifelse(plot_data3$pval < 0.05, "bold", "plain")) + 
  xlab("logOR") +
  ylab("Health Outcome Group") +
  ggtitle("B") +
  theme_minimal() +  
  annotate(geom = "text",
           x = -0.15,
           y = 5, 
           label = paste0("italic(R)^{2} == ", round(r2_mod4[1],4)),
           color ="black",
           parse = TRUE, 
           size = 5) +
  labs(caption = "The plot displays only meta-analytic estimates that were pooled from at least two meta-analyses. Black estimates were statistically different from 0.") + 
  theme(plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
         plot.title = element_text(face = "bold", size = 18),
       legend.title = element_text(size = 16),
        legend.text = element_text(size = 15),
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        axis.text.y = element_text(size = 17),
       axis.text.x = element_text(size = 17)) #+  
   #scale_x_break(c(4, 6)) +
   #scale_x_continuous(breaks = seq(0, 4, by = 1), limits = c(-0.21, 4))
  
forest_plot3
```

## Different VCV

cluster VCV over chemical and over health outcome for sensitivity analysis and check convergence of models

